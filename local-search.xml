<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>iOS-Router架构选择</title>
    <link href="/2022/02/16/IOS-Router%E6%9E%B6%E6%9E%84%E9%80%89%E6%8B%A9/"/>
    <url>/2022/02/16/IOS-Router%E6%9E%B6%E6%9E%84%E9%80%89%E6%8B%A9/</url>
    
    <content type="html"><![CDATA[<h3 id="BeeHive"><a href="#BeeHive" class="headerlink" title="BeeHive"></a>BeeHive</h3><h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><p>BeeHive的模块都必须实现一个继承自BHServiceProtocol的唯一自定义协议，此协议中定义自己想要公开的方法，是用来给其他模块调用使用的。</p><p>每个模块的自定义协议可以统一放在一个pod中，以中介者模式解决网状依赖的问题。而且该pod只会被具体的模块依赖，并不会依赖具体的模块。完全符合面向对象的依赖倒置原则——抽象不应该依赖于具体实现，具体实现应该依赖于抽象。</p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul><li>模块不存在或未注册时，不会获取到实例，可以灵活处理；</li></ul><h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>有基础协议，存在代码侵入，但其中并未封装通用性的协议方法；</li><li>BHServiceManager注册时通过协议识别模块，因此每个模块必须定义自己的协议；</li><li>通过配置文件注册时，未提供属性注入；</li><li>因为模块通过BeeHive统一注册后创建，所以Service之间的依赖，可能导致Service在注册前使用；因而需要控制Service的加载顺序；</li><li>会影响启动速度，在 <code>+load</code> 方法中注册了1000个 <code>Service Protocol</code>，启动时间影响大概是在3-4ms</li></ul><hr><h3 id="CTMediator"><a href="#CTMediator" class="headerlink" title="CTMediator"></a>CTMediator</h3><p>CTMediator的方案中，每个模块需要定义自己的Target对象，作为公共方法声明，其中定义的Action都是给其他模块调用使用的。</p><p>为了解决网状依赖的问题，可以为每个模块定义一个CTMediator的category对Target进行二次封装，这些category放在统一的pod中，作为一个中介者。按正常的逻辑，这个统一pod是会依赖具体的模块的，但是CTMediator的方案中，是利用runtime调用对应的Target-Action，所以解除了直接的代码依赖。</p><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><ul><li>Target无基础类型，所以无侵入性；</li><li>模块不需注册;</li><li>两层封装，保证灵活性；</li><li>和应用间的Route跳转可以更灵活的对接；</li></ul><h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><ul><li>Target无基础类型，缺乏抽象，模块需要自己实现Target-Action;</li><li>当模块不存在时，无法提前处理，只能设置默认处理方法；</li><li>category中都是硬编码，修改时会比较麻烦。</li></ul><hr><h3 id="为什么不直接使用业界的-CTMediator-或者-Beehive-或者-MGJRouter"><a href="#为什么不直接使用业界的-CTMediator-或者-Beehive-或者-MGJRouter" class="headerlink" title="为什么不直接使用业界的 CTMediator 或者 Beehive 或者 MGJRouter?"></a>为什么不直接使用业界的 CTMediator 或者 Beehive 或者 MGJRouter?</h3><ul><li>是我们的需求和业界的开源库不完全相符。MGJRouter 缺少服务管理，CTMediator 和设计不符，Beehive 没有路由管理同时不够轻量(很多接口还是基于阿里的需求提供的，我们用不到，会形成理解成本)。</li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-ld段位移</title>
    <link href="/2022/02/10/iOS-ld%E6%AE%B5%E4%BD%8D%E7%A7%BB/"/>
    <url>/2022/02/10/iOS-ld%E6%AE%B5%E4%BD%8D%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="TEXT-段迁移的原理"><a href="#TEXT-段迁移的原理" class="headerlink" title="__TEXT 段迁移的原理"></a>__TEXT 段迁移的原理</h3><p>程序的构建过程包含 预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接 等 4 个主要阶段，完成之后就会得到 Mach-O 可执行文件。</p><p>通过 $ man ld ，可以发现链接器有一个参数: -rename_p orgSegment orgSection newSegment newSection。使用该参数可以将orgSegment&#x2F;orgSection的名称修改为newSegment&#x2F;newSection。</p><p>可以在 Other Linker Flags 中传递该参数。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">-Wl,-rename_p,__TEXT,__text,__BD_TEXT,__text<br>-Wl,-segprot,__BD_TEXT,rx,rx<br></code></pre></td></tr></table></figure><p>其中 -Wl 的作用是告诉 Xcode 它后面的参数是添加给 Ld 链接器的，这些参数将在链接阶段生效。</p><p>第一行参数会新创建一个 __BD_TEXT 段，并把<code> __TEXT</code>  ,<code>__text </code>移动到 __<code>BD_TEXT</code>，<code>__text</code>。</p><p>第二行参数是给 <code>__BD_TEXT </code>赋予可读和可执行权限。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__cstring,__RODATA,__cstring&quot;</span>,<br><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__const,__RODATA,__const&quot;</span>,<br><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__gcc_except_tab,__RODATA,__gcc_except_tab&quot;</span>,<br><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__objc_methname,__RODATA,__objc_methname&quot;</span>,<br><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__objc_classname,__RODATA,__objc_classname&quot;</span>,<br><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__objc_methtype,__RODATA,__objc_methtype&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>使用 <code>-rename_p</code> 需要关闭 <code>Bitcode</code> </p></blockquote><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h5 id="crash"><a href="#crash" class="headerlink" title="crash"></a>crash</h5><p>Crash 的原因是执行代码时找不到指定的节</p><p>操作系统只关心段的读&#x2F;写&#x2F;执行权限，并不关心段或节的名称。即便是使用了<code>-rename_p</code> 移动 Segment&#x2F;Section，各符号的地址也会由链接器修正好，因此段移动后程序也可以正常运行。</p><p>但是如果代码指明了要读取 __TEXT 中的某个 Section ，那么这个 Section 就不能够被移动，否则代码就无法读取到它，就会导致出错。</p><p>首先，dyld 在启动阶段会检查 <code>__unwind_info</code> 和 <code>__eh_frame</code> 这两个 Section。如果移动这两个 Section，在启动后程序就会 Crash。</p><p>第二，Swift 相关的 Section 不能移动，否则会引起 Crash。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">__TEXT,__swift5_typeref<br>__TEXT,__swift5_reflstr<br>__TEXT,__swift5_fieldmd<br>__TEXT,__swift5_types<br>__TEXT,__swift5_capture<br>__TEXT,__swift5_assocty<br>__TEXT,__swift5_proto<br>__TEXT,__swift5_protos<br>__TEXT,__swift5_builtin<br></code></pre></td></tr></table></figure><h5 id="链接失败"><a href="#链接失败" class="headerlink" title="链接失败"></a>链接失败</h5><p><code>__TEXT</code> 段迁移最难解决的问题是链接失败问题，是由 CPU 对寻址范围的限制以及 ld64 链接器的缺陷导致。</p>]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-启动优化</title>
    <link href="/2022/02/08/iOS-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
    <url>/2022/02/08/iOS-%E5%90%AF%E5%8A%A8%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><h4 id="启动埋点"><a href="#启动埋点" class="headerlink" title="启动埋点"></a>启动埋点</h4><p>启动终点记录方案</p><ul><li>iOS 12 及以下：root viewController 的 viewDidAppear</li><li>iOS 13+：applicationDidBecomeActive</li></ul><h5 id="分阶段埋点"><a href="#分阶段埋点" class="headerlink" title="分阶段埋点"></a>分阶段埋点</h5><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1spfcisjuj21080dhmxy.jpg"></p><p><code>+load</code>、<code>initializer</code>的调用顺序和链接顺序有关，链接顺序又是按照 cocopods的 pod 命名升序排列，所以取一个命名为 AAA 开头的 pod ，可以让<code>+load</code>以及 <code>initializer</code> 第一个被执行</p><p>需要记录的点有: </p><ul><li>进程创建的时间<ul><li>通过 <code>sysctl</code> 系统调用拿到进程创建的时间戳</li></ul></li><li>第一个+load&#x2F;第一个initializer<ul><li>通过 AAA 为前缀命名 Pod，让 +load 第一个被执行</li></ul></li><li>main开始</li><li>finishLaunch开始<ul><li>一般<code>didFinishLaunching</code>当中优先应该执行监控APM，所以用监控APM的初始化时间作为开始</li></ul></li><li>finishLaunch结束<ul><li>当方法执行完毕记录</li></ul></li><li>启动埋点<ul><li>获取<code>CA::Transaction::commit()</code>方法被调用的时间</li></ul></li></ul><p><strong><code>CA::Transaction::commit()</code>是通过 Runloop 来驱动的，依次的时机为</strong></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1spp21exjj20t3059t8v.jpg"></p><p>可以通过在 <code>didFinishLaunching</code> 中向 Runloop 注册 block 或者 BeforeTimer 的 Observer 来获取上图中两个时间点的回调 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">if</span> (@<span class="hljs-built_in">available</span>(iOS <span class="hljs-number">13.0</span>, *)) &#123;<br><span class="hljs-comment">//注册kCFRunLoopBeforeTimers回调</span><br>CFRunLoopRef mainRunloop = [[NSRunLoop mainRunLoop] getCFRunLoop];<br>CFRunLoopActivity activities = kCFRunLoopAllActivities;<br>CFRunLoopObserverRef observer = <span class="hljs-built_in">CFRunLoopObserverCreateWithHandler</span>(kCFAllocatorDefault, activities, YES, <span class="hljs-number">0</span>, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123;<br>    <span class="hljs-keyword">if</span> (activity == kCFRunLoopBeforeTimers) &#123;<br>        NSTimeInterval stamp = [[NSDate date] timeIntervalSince1970];<br>        <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;runloop beforetimers launch end:%f &quot;</span>,stamp);<br>        <span class="hljs-built_in">CFRunLoopRemoveObserver</span>(mainRunloop, observer, kCFRunLoopCommonModes);<br>    &#125;<br>&#125;);<br>   <br><span class="hljs-built_in">CFRunLoopAddObserver</span>(mainRunloop, observer, kCFRunLoopCommonModes);<br><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">// 注册block的方式获取</span><br>    CFRunLoopRef mainBlockRunloop = [[NSRunLoop mainRunLoop] getCFRunLoop];<br>    <span class="hljs-built_in">CFRunLoopPerformBlock</span>(mainBlockRunloop,NSDefaultRunLoopMode,^()&#123;<br>        NSTimeInterval stamp = [[NSDate date] timeIntervalSince1970];<br>        <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;runloop block launch end:%f &quot;</span>,stamp);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取首屏渲染的方案"><a href="#获取首屏渲染的方案" class="headerlink" title="获取首屏渲染的方案"></a><strong>获取首屏渲染的方案</strong></h4><p>**<font color="#EA7500">iOS13（含）以上的系统采用 <code>runloop</code> 中注册一个 <code>kCFRunLoopBeforeTimers</code> 的回调获取到的 App 首屏渲染完成的时机更准确。</font>  **</p><p>**<font color="#EA7500">iOS13 以下的系统采用 <code>CFRunLoopPerformBlock</code> 方法注入 block 获取到的 App 首屏渲染完成的时机更准确。</font>  **</p><h4 id="测试阶段"><a href="#测试阶段" class="headerlink" title="测试阶段"></a>测试阶段</h4><p>如何保证测试数据的准确性，通过控制变量的方式：</p><ul><li>关闭 iCloud &amp; 不登录 AppleID &amp; 飞行模式</li><li>风扇降温，且用 MFI 认证数据线</li><li>重启手机和开始下一次测试之前静置一段时间</li><li>多次测量取平均值 &amp; 计算方差</li><li>Mock 启动过程中的 AB 变量</li></ul><p>防止启动劣化，可以做以下准入条件</p><ul><li><p>新增动态库</p></li><li><p>新增+load和静态初始化</p></li><li><p>新增启动任务</p></li></ul><p>上述都可以在 <code>git</code> 提交时，写脚本进行检测，最后<code>Code Review</code></p><p> <code>Xcode MetricKit</code> 本身也可以看到启动耗时：打开 Xcode -&gt; Window -&gt; Origanizer -&gt; Launch Time</p><h4 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h4><h5 id="当我们做数据统计的时候，需要注意的点是"><a href="#当我们做数据统计的时候，需要注意的点是" class="headerlink" title="当我们做数据统计的时候，需要注意的点是"></a>当我们做数据统计的时候，需要注意的点是</h5><ul><li><p>**<font color="#EA7500">发版本的前几天启动速度会变慢，这是因为iOS13之后更新APP的第一次启动需要创建启动闭包，这个过程比较慢，之后就会有缓存了，所以我们需要判断APP更新过后是不是第一次启动</font>  **</p></li><li><p>统计启动时间的时候，需要把手机型号，系统也一定统计进去</p></li></ul><h3 id="找出耗时点"><a href="#找出耗时点" class="headerlink" title="找出耗时点"></a>找出耗时点</h3><h4 id="Time-Profiler"><a href="#Time-Profiler" class="headerlink" title="Time Profiler"></a>Time Profiler</h4><p>**<font color="#EA7500">默认 Time Profiler 会 1ms 采样一次，只采集在运行线程的调用栈，最后以统计学的方式汇总。比如下图中的 5 次采样中，method3 都没有采样到，所以最后聚合到的栈里就看不到 method3。所以 Time Profiler 中的看到的时间，并不是代码实际执行的时间，而是栈在采样统计中出现的时间。</font>  **</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1tbziz0g5j21080lhdhq.jpg"></p><p>Time Profiler 支持一些额外的配置，<strong>如果统计出来的时间和实际的时间相差比较多，可以尝试开启</strong>：</p><ul><li>High Frequency，降低采样的时间间隔</li><li>Record Kernel Callstacks，记录内核的调用栈</li><li>Record Waiting Thread，记录被 block 的线程</li></ul><h4 id="System-Trace"><a href="#System-Trace" class="headerlink" title="System Trace"></a>System Trace</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8635a869aa06443c9ff91ecafb09d024~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><p>既然要精细化分析，那么我们就需要标记出一小段时间，可以用 Point of interest 来标记。除此之外，System Trace 分析虚拟内存和线程状态都很管用：</p><ul><li>Virtual Memory：<strong>主要关注 Page In</strong>这个事件，因为启动路径上有很多次 Page In，且相对耗时</li><li>Thread State：<strong>主要关注挂起和抢占两个状态，记住主线程不是一直在运行的</strong></li><li>System Load 线程有优先级，高优先级的线程不应该超过系统核心数量</li></ul><h4 id="os-signpost"><a href="#os-signpost" class="headerlink" title="os_signpost"></a>os_signpost</h4><p>os_signpost 是 iOS 12 推出的用于在 instruments 里标记时间段的 API，性能非常高，可以认为对启动无影响。结合最开始讲的分阶段监控，我们可以在 Instrument 把启动划分成多个阶段，和其他模板一起分析具体问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//耗时统计</span><br>- (<span class="hljs-type">void</span>)viewDidAppear:(BOOL)animated &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     统计这段区间的执行次数,耗时,等等,更加直观</span><br><span class="hljs-comment">     SP_BEGIN_LOG(systemname, category, name);</span><br><span class="hljs-comment">     systemname:自定义,可以用bundleId</span><br><span class="hljs-comment">     category:在timeprofile中统计分类时使用,相同的扼categroy在同一个分类下</span><br><span class="hljs-comment">     name:具体统计名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-built_in">SP_BEGIN_LOG</span>(custome, gl_log, viewDidAppear);<br>    [super viewDidAppear:animated];<br>    [NSThread sleepForTimeInterval:<span class="hljs-number">2</span>];<br>    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;viewDidAppear&quot;</span>);<br>    <span class="hljs-built_in">SP_END_LOG</span>(viewDidAppear);<br>    <br>    <br>    <span class="hljs-type">os_log_t</span> m_log = <span class="hljs-built_in">os_log_create</span>(<span class="hljs-string">&quot;custome&quot;</span>, <span class="hljs-string">&quot;gl_log&quot;</span>);\<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-type">os_signpost_id_t</span> signid_1 = <span class="hljs-built_in">os_signpost_id_generate</span>(m_log);<br>        <span class="hljs-built_in">os_signpost_interval_begin</span>(m_log, signid_1, <span class="hljs-string">&quot;asynctest&quot;</span>);<br>        <span class="hljs-built_in">dispatch_async</span>(<span class="hljs-built_in">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="hljs-number">0</span>), ^&#123;<br>            <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;打印的第%d遍&quot;</span>,i);<br>            <span class="hljs-built_in">os_signpost_interval_end</span>(m_log, signid_1, <span class="hljs-string">&quot;asynctest&quot;</span>, <span class="hljs-string">&quot;index%d&quot;</span>,i);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1tvc3xt5ij20u20h8769.jpg"></p><p>这边因为我在<code>viewDidAppear</code>中设置了睡眠2s，所以上图中时间是2.00s</p><p>其实我for循环了10次，也就是打印了10次<code>asynctest</code>，最后的count为10</p><p>**<font color="#EA7500">我们可以结合swizzle，os_signpost来达到统计的效果，hook所有的load方法，来分析启动时所有load的耗时，hook所有的UIImage加载方法，来统计启动路径上用到的图片加载耗时时间</font>  **</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abe2e95368914aabbd06594917b16a4c~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><ol><li><strong>删</strong>掉启动项，最直接</li><li>如果不能删除，尝试<strong>延迟</strong>，延迟包括第一次访问以及启动结束后找个合适的时间预热</li><li>不能延迟的可以尝试<strong>并发</strong>，利用好多核多线程</li><li>如果并发也不行，可以尝试让代码执行<strong>更快</strong></li></ol><h4 id="man函数之前"><a href="#man函数之前" class="headerlink" title="man函数之前"></a>man函数之前</h4><p>我们来回顾一下 main 函数之前做了什么事情</p><ul><li>加载 dyld</li><li>创建启动闭包（更新 App&#x2F;重启手机需要）</li><li>加载动态库</li><li>Bind &amp; Rebase &amp; Runtime 初始化</li><li>+load 和静态初始化</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1ufro38k8j210802yt8x.jpg"></p><h5 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h5><p>减少动态库数量可以减少启动闭包创建和加载动态库阶段的耗时</p><p>推荐的方案</p><ul><li>动态库转静态库</li><li>非必要动态库转为懒加载形式</li></ul><h5 id="无用代码检测"><a href="#无用代码检测" class="headerlink" title="无用代码检测"></a>无用代码检测</h5><p>基于 Mach-O 的静态扫描</p><ul><li><code>_objc_selrefs</code> 和<code>_objc_classrefs</code> 存储了引用到的 sel 和 class</li><li><code>__objc_classlist</code> 存储了所有的 sel 和 class</li></ul><p>二者做个差集就知道那些类&#x2F;sel 用不到，但<strong>objc 支持运行时调用，删除之前还要在二次确认</strong></p><h5 id="load-方法迁移"><a href="#load-方法迁移" class="headerlink" title="+load 方法迁移"></a>+load 方法迁移</h5><p><strong>+load 除了方法本身的耗时，还会引起大量 Page In</strong>，另外 +load 的存在对 App 稳定性也是冲击，因为 Crash 了捕获不到。</p><p>例如一些非必要执行的方法，可以放到main之后执行的，可以延迟执行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">JYProtocolInfo</span>&#123;<br>    <span class="hljs-type">char</span> *className;<br>    <span class="hljs-type">char</span> *method;<br>&#125;;<br><br> <br><span class="hljs-meta">#<span class="hljs-keyword">define</span> JYProtocolRegister(_className_,_method_)\</span><br><span class="hljs-meta">__attribute__((used)) static struct JYProtocolInfo JYProtocolInfo##_className_ \</span><br><span class="hljs-meta">__attribute__ ((used, section (<span class="hljs-string">&quot;__DATA,JYLoadDelayData&quot;</span>))) =\</span><br><span class="hljs-meta">&#123;\</span><br><span class="hljs-meta">    .className = #_className_,\</span><br><span class="hljs-meta">    .method = #_method_,\</span><br><span class="hljs-meta">&#125;;</span><br></code></pre></td></tr></table></figure><p><strong>宏提供接口，编译期把类名和方法名写到二进制的指定段里，运行时把这个关系读出来就可以通过objc_msgSend调用了</strong></p><p>DI 的容器需要把协议绑定到类，所以需要在启动的早期(+load)里注册</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">+ (<span class="hljs-type">void</span>)load<br>&#123;<br>    [DICenter bindClass:IMPClass toProtocol:@<span class="hljs-built_in">protocol</span>(SomeProcotol)]<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以通过<strong>宏提供接口，编译期把类名和协议名写到二进制的指定段里，运行时把这个关系读出来就知道协议是绑定到哪个类了</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> * cls;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> * protocol;<br>&#125;_di_pair;<br><br><span class="hljs-comment">// _DI_VALID_METHOD 这个方法只在 debug 模式下存在，为了让编译器保证类型安全。</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> DEBUG</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> DI_SERVICE(PROTOCOL_NAME,CLASS_NAME)\</span><br><span class="hljs-meta">__used static Class<span class="hljs-string">&lt;PROTOCOL_NAME&gt;</span> _DI_VALID_METHOD(void)&#123;\</span><br><span class="hljs-meta">    return [CLASS_NAME class];\</span><br><span class="hljs-meta">&#125;\</span><br><span class="hljs-meta">__attribute((used, section(_DI_SEGMENT <span class="hljs-string">&quot;,&quot;</span> _DI_SECTION ))) static _di_pair _DI_UNIQUE_VAR = \</span><br><span class="hljs-meta">&#123;\</span><br><span class="hljs-meta">_TO_STRING(CLASS_NAME),\</span><br><span class="hljs-meta">_TO_STRING(PROTOCOL_NAME),\</span><br><span class="hljs-meta">&#125;;\</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>__attribute((used, <span class="hljs-built_in">section</span>(_DI_SEGMENT <span class="hljs-string">&quot;,&quot;</span> _DI_SECTION ))) <span class="hljs-type">static</span> _di_pair _DI_UNIQUE_VAR = \<br>&#123;\<br>_TO_STRING(CLASS_NAME),\<br>_TO_STRING(PROTOCOL_NAME),\<br>&#125;;\<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h5 id="静态初始化迁移"><a href="#静态初始化迁移" class="headerlink" title="静态初始化迁移"></a>静态初始化迁移</h5><p>大多数静态初始化引起的 Page In，一般来自 C++ 代码</p><p>迁移思路：</p><ul><li>std:string 转换成 const char *</li><li>静态变量移动到方法内部，因为方法内部的静态变量会在方法第一次调用的时候初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//Bad</span><br><span class="hljs-keyword">namespace</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> std::string bucket[] = &#123;<span class="hljs-string">&quot;apples&quot;</span>, <span class="hljs-string">&quot;pears&quot;</span>, <span class="hljs-string">&quot;meerkats&quot;</span>&#125;;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">const</span> std::string <span class="hljs-title">GetBucketThing</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> bucket[i];<br>&#125;<br><br><span class="hljs-comment">//Good</span><br><span class="hljs-function">std::string <span class="hljs-title">GetBucketThing</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>  <span class="hljs-type">static</span> <span class="hljs-type">const</span> std::string bucket[] = &#123;<span class="hljs-string">&quot;apples&quot;</span>, <span class="hljs-string">&quot;pears&quot;</span>, <span class="hljs-string">&quot;meerkats&quot;</span>&#125;;<br>  <span class="hljs-keyword">return</span> bucket[i];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Main函数之后"><a href="#Main函数之后" class="headerlink" title="Main函数之后"></a>Main函数之后</h4><p>最好需要一个启动器来管理启动项，所以的业务仓库需要实现启动器的协议来表明这是个启动任务，里面会有启动任务的顺序和执行线程</p><ul><li><p><strong>全局并发调度</strong>：比如 AB 任务并发，C 任务等待 AB 执行完毕，框架调度还能减少线程数量和控制优先级</p></li><li><p><strong>延迟执行</strong>：提供一些时机，业务可以做预热性质的初始化</p></li><li><p><strong>精细化监控</strong>：所有任务的耗时都能监控到，线下自动化监控也能受益</p></li><li><p><strong>管控</strong>：启动任务的顺序调整，新增&#x2F;删除都能通过 Code Review 管控</p></li></ul><h5 id="三方SDK"><a href="#三方SDK" class="headerlink" title="三方SDK"></a>三方SDK</h5><p>例如环信等三方SDK，如果非必要，可以推迟加载的时间</p><h5 id="高频方法"><a href="#高频方法" class="headerlink" title="高频方法"></a>高频方法</h5><p>如果启动过程当中，会调用很多次的方法，例如读取 Info.plist 里面的配置等等，可以加一层内存缓存，这种问题在 TimeProfiler 中时间段选长可以看出</p><h5 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h5><p>锁之所以会影响启动时间，是因为有时候子线程先持有了锁，<strong>主线程就需要等待子线程锁释放。还要警惕系统会有很多隐藏的全局锁</strong></p><h5 id="线程数量"><a href="#线程数量" class="headerlink" title="线程数量"></a>线程数量</h5><p>线程的数量和优先级都会影响启动时间。可以通过设置 QoS 来配置优先级，两个高优的 QoS 是 User Interactive&#x2F;Initiated，启动的时候，<strong>需要主线程等待的子线程任务都应该设置成高优的</strong>。</p><p><strong>高优的线程数量不应该多于 CPU 核心数量</strong>，可以通过 System Trace 的 System Load 来分析这种情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">/GCD<br><span class="hljs-type">dispatch_queue_attr_t</span> attr = <span class="hljs-built_in">dispatch_queue_attr_make_with_qos_class</span>(DISPATCH_QUEUE_SERIAL, QOS_CLASS_UTILITY, <span class="hljs-number">-1</span>);<br><span class="hljs-type">dispatch_queue_t</span> queue = <span class="hljs-built_in">dispatch_queue_create</span>(<span class="hljs-string">&quot;com.custom.utility.queue&quot;</span>, attr);<br><span class="hljs-comment">//NSOperationQueue</span><br>operationQueue.qualityOfService = NSQualityOfServiceUtility<br><br></code></pre></td></tr></table></figure><h5 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h5><p><strong>用 Asset 管理图片而不是直接放在 bundle 里</strong>。Asset 会在编译期做优化，让加载的时候更快，此外在 Asset 中加载图片是要比 Bundle 快的，因为 UIImage imageNamed 要遍历 Bundle 才能找到图。<strong>加载 Asset 中图的耗时主要在在第一次张图，因为要建立索引</strong>，可以通过把启动的图放到一个小的 Asset 里来减少这部分耗时。</p><p> 每次创建 UIImage 都需要 IO，在首帧渲染的时候会解码。所以可以通过提前子线程预加载（创建 UIImage）来优化这部分耗时。<strong>可以在启动的早期开预加载的子线程启动任务</strong>。</p><h5 id="Fishhook"><a href="#Fishhook" class="headerlink" title="Fishhook"></a>Fishhook</h5><p>fishhook 是一个用来 hook C 函数的库，但这个库的第一次调用耗时很高，最好<strong>不要带到线上</strong>。Fishhook 是按照下图的方式遍历 Mach-O 的多个段来找函数指针和函数符号名的映射关系，带来的**副作用就是要大量的 Page In，对于大型 App 来说在 iPhone X 冷启耗时 200ms+**。</p><p> <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1v540rn8ij21080arq3p.jpg"></p><p>如果不得不用 fishhook，<strong>请在子线程调用，且不要在在<code>_dyld_register_func_for_add_image</code>直接调用 fishhook</strong>。因为这个方法会持有 dyld 的一个全局互斥锁，主线程在启动的时候系统库经常会调用 <code>dlsym</code> 和 <code>dlopen</code>，其内部也需要这个锁，造成上文提到的子线程阻塞主线程。</p><h5 id="段重命名"><a href="#段重命名" class="headerlink" title="段重命名"></a>段重命名</h5><p>因为 iOS13 以下，App Store 会对上传的 App 的 TEXT 段加密，在发生 Page In 的时候会解密，解密的过程是很耗时的，我们可以通过 链接参数将TEXT段中的内容移动到新的段，ld 也有个参数 <code>rename_section</code> 支持重命名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__cstring,__RODATA,__cstring&quot;</span>,<br><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__const,__RODATA,__const&quot;</span>,<br><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__gcc_except_tab,__RODATA,__gcc_except_tab&quot;</span>,<br><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__objc_methname,__RODATA,__objc_methname&quot;</span>,<br><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__objc_classname,__RODATA,__objc_classname&quot;</span>,<br><span class="hljs-string">&quot;-Wl,-rename_section,__TEXT,__objc_methtype,__RODATA,__objc_methtype&quot;</span><br></code></pre></td></tr></table></figure><p>这种做法的话，需要注意移动的Text段大小问题</p><h5 id="二进制重排"><a href="#二进制重排" class="headerlink" title="二进制重排"></a>二进制重排</h5><p>以下图为例，方法 1 和方法 3 是启动的时候用到的，为了执行对应的代码，就需要两次 Page In。假如我们把方法 1 和 3 排列到一起，那么只需要一次 Page In，从而提升启动速度。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80b153b8b17848bda954cab6cb9ae93d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><p>链接器 ld 有个参数-order_file 支持按照符号的方式排列二进制。获取启动时候用到的符号主流有两种方式：</p><ul><li>抖音方案：静态扫描获取 +load 和 C++静态初始化，hook objc_msgSend 获取 Objective C 符号。</li><li>Facebook 方案：LLVM 函数插桩，灰度统计启动路径符号，用大多数用户的符号生成 order_file。</li></ul><h5 id="动态库懒加载"><a href="#动态库懒加载" class="headerlink" title="动态库懒加载"></a>动态库懒加载</h5><p>运行时通过<code>-[NSBundle load]</code>来加载，本质上调用的是底层的 <code>dlopen</code>。</p><p>动态库懒加载除了启动加载的代码减少，还能长期防止业务增加代码引起启动劣化，因为业务的初始化在第一次访问的时候完成的。</p><p>这个方案还有其他优点，比如动态库化后本地编译时间会大幅度降低，对其他性能指标也有好处，缺点是会牺牲一定程度的包大小，但可以用段压缩等方式优化懒加载的动态库来打平这部分损耗。</p><h5 id="Background-Fetch"><a href="#Background-Fetch" class="headerlink" title="Background Fetch"></a>Background Fetch</h5><p>Background Fetch 可以隔一段时间把 App 在后台启动，对于时间敏感的 App（比如新闻）可以在后台刷新数据，这样能够提高 Feed 加载的速度，进而提升用户体验。</p><p>那么，这种类似“后台保活”的机制，为什么能提高启动速度呢？我们来看一个典型的 case：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5fdb6f6a52b146ed868a51824553b681~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><ol><li>系统在后台启动 App</li><li>时间长因为内存等原因，后台的 App 被 kill 了</li><li>这时候用户立刻启动 App，那么这次启动就是一次<strong>热启动</strong>，因为缓存还在</li><li>又一次系统在后台启动 App</li><li>这次用户在 App 在后台的时候点了 App，那么这次启动就是一次<strong>后台回前台</strong>，因为 App 仍然活着</li></ol><p>通过这两个典型的场景，可以看出来为什么 Background Fetch 能提高启动速度了：</p><ul><li><strong>提高热启动在冷启动的占比</strong></li><li><strong>后台启动回前台被定义为启动，因为用户的角度来说这就是一次启动</strong></li></ul><p>后台启动有一些要注意的点，<strong>比如日活，广告，甚至是 AB 进组逻辑都会受影响</strong>，需要做不少适配。往往需要启动器来支撑，因为正常启动在 didFinishLaunch 执行的任务，在后台启动的时候需要延迟到第一次回前台的时候再执行。</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://juejin.cn/post/6921508850684133390">抖音品质建设 - iOS启动优化《实战篇》</a></p><p><a href="https://www.jianshu.com/p/d9dc0bbc8535">os_signpost</a></p><p><a href="https://blog.csdn.net/ByteDanceTech/article/details/111878196">今日头条优化实践</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-启动流程</title>
    <link href="/2022/02/04/iOS-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <url>/2022/02/04/iOS-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><p>最近做了启动优化相关APM，故此将启动的原理整理了一遍。</p><ul><li>起点： 进程创建的时间</li><li>终点： 第一个<code>CA::Transaction::commit()</code></li></ul><h4 id="启动的种类"><a href="#启动的种类" class="headerlink" title="启动的种类"></a>启动的种类</h4><p>根据场景的不同，启动可以分为三种：冷启动，热启动和回前台。</p><ul><li>**<font color="#EA7500">冷启动：系统里没有任何进程的缓存信息，典型的是重启手机后直接启动 App</font>  **</li><li>**<font color="#EA7500">热启动：如果把 App 进程杀了，然后立刻重新启动，这次启动就是热启动，因为进程缓存还在</font>  **</li><li>**<font color="#EA7500">回前台：大多数时候不会被定义为启动，因为此时 App 仍然活着，只不过处于 suspended 状态</font>  **</li></ul><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>虚拟内存就是一层间接寻址（indirection），虚拟内存解决的是管理所有进程使用物理 RAM 的问题。通过添加间接层来让每个进程使用逻辑地址空间，它可以映射到 RAM 上的某个物理页上。这种映射不是一对一的，逻辑地址可能映射不到 RAM 上，也可能有多个逻辑地址映射到同一个物理 RAM 上。针对第一种情况，当进程要存储逻辑地址内容时会触发 page fault；第二种情况就是多进程共享内存。</p><p>page fault 会阻塞该进程，将磁盘中对应<code>Page</code>的数据加载到内存，把虚拟内存指向物理内存</p><p>**<font color="#EA7500">对于文件可以不用一次性读入整个文件，可以使用分页映射（<code>mmap()</code>）的方式读取。也就是把文件某个片段映射到进程逻辑内存的某个页上。当某个想要读取的页没有在内存中，就会触发 page fault，内核只会读入那一页，实现文件的懒加载。也就是说 Mach-O 文件中的 <code>__TEXT</code> 段可以映射到多个进程，并可以懒加载，且进程之间共享内存。 </font>  **</p><p><strong><font color="#EA7500"><code>__DATA</code> 段是可读写的。 这里使用到了 Copy-On-Write 技术，简称 COW。也就是多个进程共享一页内存空间时，一旦有进程要做写操作，它会先将这页内存内容复制一份出来，然后重新映射逻辑地址到新的 RAM 页上。</font></strong>  </p><p>也就是这个进程自己拥有了那页内存的拷贝。这就涉及到了 clean&#x2F;dirty page 的概念。dirty page 含有进程自己的信息，而 clean page 可以被内核重新生成（重新读磁盘）。所以 dirty page 的代价大于 clean page。</p><p><strong><font color="#EA7500"><code>dirty page</code> ：使用中的物理内存块如果不交换到硬盘保存状态就不能复用，那么就是<code>Dirty</code>的内存块，比如你主动<code>malloc</code>出来的内存块，如果不保留其中的状态就把它给别人用，那你肯定就无法恢复这个内存块的信息，所以它是<code>Dirty</code>的。</font></strong>  </p><p><strong><font color="#EA7500"><code>clean page</code>： 如果是一个映射到内存的文件，就算使用它的内存块，还是可以重新从磁盘载入文件到内存的，所以是非Dirty的。</font></strong>  </p><p><code>mmap（memory map）</code>:   是一种内存映射技术，可以把文件映射到虚拟内存的地址空间里，这样就可以像直接操作内存那样来读写文件。<strong>当读取虚拟内存，其对应的文件内容在物理内存中不存在的时候，会触发一个事件：File Backed Page In，把对应的文件内容读入物理内存</strong>。</p><p>启动的时候，Mach-O 就是通过 mmap 映射到虚拟内存里的(如下图)。下图中部分页被标记为 zero fill，是因为全局变量的初始值往往都是 0，那么这些 0 就没必要存储在二进制里，增加文件大小。操作系统会识别出这些页，在 Page In 之后对其置为 0，这个行为叫做 zero fill。</p><p> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e63e671214e4c9e9fbe79e142afcb00~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><h4 id="Page-In"><a href="#Page-In" class="headerlink" title="Page In"></a>Page In</h4><p>启动的路径上会触发很多次 Page In，其实也比较容易理解，因为启动的会读写二进制中的很多内容。<strong>Page In 会占去启动耗时的很大一部分</strong>，我们来看看单个 Page In 的过程：</p><p> <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1o3zvsprfj21080bzaan.jpg"></p><ul><li><strong><font color="#EA7500">MMU 找到空闲的物理内存页面</font></strong>  </li><li><strong><font color="#EA7500">触发磁盘 IO，把数据读入物理内存</font></strong>  </li><li><strong><font color="#EA7500">如果是 TEXT 段的页，要进行解密</font></strong>  </li><li><strong><font color="#EA7500">对解密后的页，进行签名验证</font></strong></li></ul><p>其中<strong>解密是大头，IO 其次。</strong></p><p>为什么要解密呢？因为 iTunes Connect 会对上传 Mach-O 的 TEXT 段进行加密，防止 IPA 下载下来就直接可以看到代码。这也就是为什么逆向里会有个概念叫做“砸壳”，砸的就是这一层 TEXT 段加密。</p><p><strong><font color="#EA7500">iOS 13 对这个过程进行了优化，Page In 的时候不需要解密了</font></strong>  </p><h6 id="二进制重排"><a href="#二进制重排" class="headerlink" title="二进制重排"></a>二进制重排</h6><p>启动具有<strong>局部性特征</strong>，即只有少部分函数在启动的时候用到，这些函数在二进制中的分布是零散的，所以 Page In 读入的数据利用率并不高。如果我们可以把启动用到的函数排列到二进制的连续区间，那么就可以减少 Page In 的次数，从而优化启动时间</p><h4 id="IPA的构建"><a href="#IPA的构建" class="headerlink" title="IPA的构建"></a>IPA的构建</h4><p>既然要构建，那么必然会有一些地方去定义如何构建，对应 Xcode 中的两个配置项：</p><p><strong>Build Phase：以 Target 为维度定义了构建的流程</strong>。</p><p>可以在 Build Phase 中插入脚本，来做一些定制化的构建，比如 CocoaPod 的拷贝资源就是通过脚本的方式完成的。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1oe3u656sj21080gkaay.jpg"> </p><ul><li><p><strong><font color="#EA7500">源文件(.m&#x2F;.c&#x2F;.swift 等)是单独编译的，输出对应的目标文件(.o)</font></strong>  </p></li><li><p><strong><font color="#EA7500">目标文件和静态库&#x2F;动态库一起，链接出最后的 Mach-O</font></strong>  </p></li><li><p><strong><font color="#EA7500">Mach-O 会被裁剪，去掉一些不必要的信息</font></strong>  </p></li><li><p><strong><font color="#EA7500">资源文件如 storyboard，asset 也会编译，编译后加载速度会变快</font></strong>  </p></li><li><p><strong><font color="#EA7500">Mach-O 和资源文件一起，打包出最后的.app</font></strong>  </p></li><li><p><strong><font color="#EA7500">对.app 签名，防篡改</font></strong></p></li></ul><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>编译器可以分为两大部分：前端和后端，二者以 <code>IR</code>（中间代码）作为媒介。这样前后端分离，使得前后端可以独立的变化，互不影响。C 语言家族的前端是 <code>clang</code>，<code>swift</code> 的前端是 <code>swiftc</code>，二者的后端都是 <code>llvm</code>。</p><ul><li>前端负责预处理，词法语法分析，生成 IR</li><li>后端基于 IR 做优化，生成机器码</li></ul><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>经过编译后，我们有很多个目标文件，接着这些目标文件会和静态库，动态库一起，链接出一个 Mach-O。链接的过程并不产生新的代码，只会做一些移动和补丁。</p><ul><li>tbd 的全称是 text-based stub library，是因为链接的过程中只需要符号就可以了，所以 Xcode 6 开始，像 UIKit 等系统库就不提供完整的 Mach-O，而是提供一个只包含符号等信息的 tbd 文件。</li></ul><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1oggbtqfaj20i108xjrh.jpg"></p><h4 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h4><p>编译完 Mach-O 之后会进行裁剪(strip)，是因为里面有些信息，如调试符号，是不需要带到线上去的。裁剪有多种级别，一般的配置如下：</p><ul><li>All Symbols，主二进制</li><li>Non-Global Symbols，动态库</li><li>Debugging Symbols，二方静态库</li></ul><p><strong>为什么二方库在出静态库的时候要选择 Debugging Symbols 呢？是因为像 order_file 等链接期间的优化是基于符号的，如果把符号裁剪掉，那么这些优化也就不会生效了</strong>。</p><h4 id="签名-amp-上传"><a href="#签名-amp-上传" class="headerlink" title="签名 &amp; 上传"></a>签名 &amp; 上传</h4><p>裁剪完二进制后，会和编译好的资源文件一起打包成.app 文件，接着对这个文件进行签名。签名的作用是保证文件内容不多不少，没有被篡改过。接着会把包上传到 iTunes Connect，上传后会对<code>__TEXT</code>段加密，加密会减弱 IPA 的压缩效果，增加包大小，也会降低启动速度 <strong>（iOS 13 优化了加密过程，不会对包大小和启动耗时有影响）</strong></p><h3 id="Dyld"><a href="#Dyld" class="headerlink" title="Dyld"></a>Dyld</h3><h4 id="创建启动闭包"><a href="#创建启动闭包" class="headerlink" title="创建启动闭包"></a>创建启动闭包</h4><p>dyld 会首先创建启动闭包，闭包是一个缓存，用来提升启动速度的。既然是缓存，那么必然不是每次启动都创建的，只有在重启手机或者更新&#x2F;下载 App 的第一次启动才会创建。<strong>闭包存储在沙盒的 tmp&#x2F;com.apple.dyld 目录，清理缓存的时候切记不要清理这个目录</strong>。</p><h4 id="闭包做了什么事？"><a href="#闭包做了什么事？" class="headerlink" title="闭包做了什么事？"></a>闭包做了什么事？</h4><ul><li>dependends，依赖动态库列表</li><li>fixup：bind &amp; rebase 的地址</li><li>initializer-order：初始化调用顺序</li><li>optimizeObjc: Objective C 的元数据</li><li>其他：main entry, uuid…</li></ul><p><strong><font color="#EA7500">动态库的依赖是树状的结构，初始化的调用顺序是先调用树的叶子结点，然后一层层向上，最先调用的是 <code>libSystem</code>，因为他是所有依赖的源头。</font></strong>  </p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c98498fff55540edaf8c01c522183bc0~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><h5 id="闭包为什么能提高启动速度？"><a href="#闭包为什么能提高启动速度？" class="headerlink" title="闭包为什么能提高启动速度？"></a>闭包为什么能提高启动速度？</h5><p><strong><font color="#EA7500">因为这些信息是每次启动都需要的，把信息存储到一个缓存文件就能避免每次都解析，尤其是 Objective C 的运行时数据（Class&#x2F;Method…）解析非常慢</font></strong>  </p><h5 id="dyld2和dyld3的区别？"><a href="#dyld2和dyld3的区别？" class="headerlink" title="dyld2和dyld3的区别？"></a>dyld2和dyld3的区别？</h5><p>dyld2和dyld3的主要区别就是没有启动闭包</p><ul><li>解析动态库的依赖关系</li><li>解析<code>LINKEDIT</code>，找到<code>bind&amp;rebase</code>的指针地址，找到<code>bind</code>的符号地址</li><li>注册<code>objc</code>的<code>Class/Method</code>等元数据</li></ul><h4 id="fixup"><a href="#fixup" class="headerlink" title="fixup"></a>fixup</h4><p>有了闭包之后，就可以用闭包启动 App 了。这时候很多动态库还没有加载进来，会首先对这些动态库 <code>mmap</code> 加载到虚拟内存里。接着会对每个 Mach-O 做<code> fixup</code>，包括 <code>Rebase </code>和 <code>Bind</code></p><ul><li>Rebase：修复内部指针<ul><li>因为Mach-O在<code>mmap</code>到虚拟内存的时候，会有一个随机的偏移量<code>slide</code>，需要把内部的指针 + <code>slide</code></li></ul></li><li>Bind：修复外部指针<ul><li>调用了外部函数，只有运行时才能知道具体地址是多少，<code>bind</code>就是把指针指向这个地址</li></ul></li></ul><p>例如一个字符串<code>@&quot;jyjyjyjy&quot;</code>,编译到最后的二进制文件当中会存储在两个section里</p><ul><li><p><code>__TEXT，__cstring</code>，存储实际的字符串<code>&quot;jyjyjyjy&quot;</code></p></li><li><p><code>__DATA，__cfstring</code>，存储 Objective C 字符串的元数据，每个元数据占用 32<code>Byte</code>，里面有两个指针</p><ul><li>内部指针，指向<code>__TEXT，__cstring</code>中字符串的位置；</li><li>外部指针 isa，指向类对象的，这就是为什么可以对 OC 的字符串字面量发消息的原因。</li></ul></li></ul><h4 id="LibSystem-Initializer"><a href="#LibSystem-Initializer" class="headerlink" title="LibSystem - Initializer"></a>LibSystem - Initializer</h4><p>当Rebase和Bind结束之后，首先会执行LibSystem的Initializer，做一些初始化工作</p><ul><li><p>初始化<code>libdispatch</code></p></li><li><p>初始化objc runtime、注册sel、加载category</p></li></ul><p><strong><font color="#EA7500">注意这里没有初始化 objc 的类方法等信息，是因为启动闭包的缓存数据已经包含了 optimizeObjc</font></strong>  </p><h4 id="Load-amp-Static-Initializer"><a href="#Load-amp-Static-Initializer" class="headerlink" title="Load &amp; Static Initializer"></a>Load &amp; Static Initializer</h4><p>接下来会进行 main 函数之前的一些初始化，主要包括+load 和 static initializer。这两类初始化函数都有个特点：<strong>调用顺序不确定，和对应文件的链接顺序有关系</strong>。那么就会存在一个隐藏的坑：有些注册逻辑在+load 里，对应会有一些地方读取这些注册的数据，如果在+load 中读取，很有可能读取的时候还没有注册。</p><p>那么，如何找到代码里有哪些 load 和 static initializer 呢？</p><p>在 Build Settings 里可以配置 write linkmap，这样在生成的 linkmap 文件里就可以找到有哪些文件里包含 load 或者 static initializer：</p><ul><li><code>__mod_init_func</code>，static initializer</li><li><code>__objc_nlclslist</code>，实现+load 的类</li><li><code>__objc_nlcatlist</code>，实现+load 的 Category</li></ul><h5 id="load方法耗时吗？"><a href="#load方法耗时吗？" class="headerlink" title="load方法耗时吗？"></a>load方法耗时吗？</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">+ (<span class="hljs-type">void</span>)load <br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1234&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><font color="#EA7500">这段代码编译完之后，这个函数会储存在<code>Mach-O</code>中的<code>TEXT</code>两个段中，<code>__text</code>存函数二进制，<code>cstring</code>存储字符串 <code>1234</code></font></strong>  </p><p><strong><font color="#EA7500">要执行<code>printf</code>函数，首先需要访问<code>__text</code>触发一次<code>page In</code> 读入物理内存，为了要打印字符串，还需要访问<code>cstring</code>，还会触发一次<code>page In</code></font></strong>  </p><p> 为了执行这个函数，系统付出了两个<code>page In</code>的代价，所以一旦<code>load</code>方法过多，会影响启动速度</p><h4 id="static-initializer-产生的条件"><a href="#static-initializer-产生的条件" class="headerlink" title="static initializer 产生的条件"></a>static initializer 产生的条件</h4><ul><li><code>__attribute__((constructor))</code></li><li><code>static class object</code></li><li><code>static object in global namespace</code></li></ul><p><strong><font color="#EA7500">并不是所有的<code>static</code>变量都会产生静态初始化，如果你开启了编译优化，对于在编译期就能确定的变量，编译器会直接将变量<code>inline</code></font></strong>  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//会产生静态初始化</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span>&#123; <br><span class="hljs-type">static</span> <span class="hljs-type">const</span> std::string var_1; <br>&#125;;<br><span class="hljs-type">const</span> std::string var_2 = <span class="hljs-string">&quot;1234&quot;</span>; <br><span class="hljs-type">static</span> Logger logger;<br><span class="hljs-comment">//不会产生静态初始化</span><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> var_3 = <span class="hljs-number">4</span>; <br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * var_4 = <span class="hljs-string">&quot;1234&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="UIKit-Init"><a href="#UIKit-Init" class="headerlink" title="UIKit Init"></a>UIKit Init</h4><p>当<code>+load</code>和<code>static initializer</code>执行完毕以后，开始执行<code>main</code>函数，<code>main</code>函数中会初始化<code>UIKit</code></p><ul><li>UIKit<ul><li>初始化<code>UIApplication</code></li><li>启动主线程的<code>Runloop</code></li></ul></li></ul><p><strong><font color="#EA7500">由于主线程的 <code>dispatch_async</code> 是基于 runloop 的，所以在+load 里如果调用了 <code>dispatch_async </code>会在这个阶段执行</font></strong>  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">+(<span class="hljs-type">void</span>)load&#123;<br>    <span class="hljs-built_in">dispatch_async</span>(<span class="hljs-built_in">dispatch_get_global_queue</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), ^&#123;<br>        <span class="hljs-comment">// 耗时的操作</span><br>        <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;123&quot;</span>);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的<code> NSLog(@&quot;123&quot;)</code>函数则是在<code>main</code>函数中启动主线程<code>Runloop</code>之后执行 </p><h4 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h4><p><code>runloop</code>实际是一个<code>do while</code>循环，与启动有什么关系？</p><ul><li><strong><font color="#EA7500">App 的 <code>LifeCycle</code> 方法是基于 Runloop 的 Source0 的</font></strong></li></ul><ul><li><strong><font color="#EA7500">首帧渲染是基于 <code>Runloop Block</code> 的</font></strong></li></ul><blockquote><p><code>LifeCycle</code> 是指<code>finishLaunch</code>开始 ~ <code>finishLaunch</code>结束</p></blockquote><h3 id="AppLifeCycle"><a href="#AppLifeCycle" class="headerlink" title="AppLifeCycle"></a>AppLifeCycle</h3><p>UIKit 初始化之后，就进入了我们熟悉的 <code>UIApplicationDelegate</code> 回调了，在这些会调里去做一些业务上的初始化：</p><ul><li><code>willFinishLaunch</code></li><li><code>didFinishLaunch</code></li><li><code>didFinishLaunchNotification</code></li></ul><p>要特别提一下 <code>didFinishLaunchNotification</code>，是因为大家在埋点的时候通常会忽略还有这个通知的存在，导致把这部分时间算到 UI 渲染里。</p><h4 id="First-Frame-Render"><a href="#First-Frame-Render" class="headerlink" title="First Frame Render"></a>First Frame Render</h4><p>一般会已<code>rootController</code>的<code>viewDidApper</code>作为渲染的终点</p><p><code>Apple</code>在<code>MetricsKit</code>里对启动终点定义是第一个<code>CA::Transaction::commit()</code></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1s684rkcsj210805adg1.jpg"></p><blockquote><p>iOS 的渲染是在一个单独的进程 <code>RenderServer</code> 做的，App 会把 <code>Render Tree</code> 编码打包给 <code>RenderServer</code>，<code>RenderServer</code> 再调用渲染框架(Metal&#x2F;OpenGL ES)来生成 <code>bitmap</code>，放到帧缓冲区里，硬件根据时钟信号读取帧缓冲区内容，完成屏幕刷新。<code>CATransaction</code> 就是把一组 UI 上的修改，合并成一个事务，通过 <code>commit</code> 提交。</p></blockquote><ul><li>渲染 又可以分为四个步骤<ul><li><strong><font color="#EA7500">Layout（布局）</font></strong>  <ul><li><strong><font color="#EA7500"><code>Root Layer</code>调用<code>[CALayer layoutSubLayers]</code>，这时候 <code>UIViewController</code> 的 <code>viewDidLoad</code> 和 <code>LayoutSubViews</code> 会调用，<code>autolayout</code> 也是在这一步生效</font></strong></li></ul></li><li><strong><font color="#EA7500">Display（绘制）</font></strong>  <ul><li><strong><font color="#EA7500"><code>Root Layer</code> 调用<code>[CALayer display]</code>，如果视图实现了 <code>drawRect</code> 方法，会在这个阶段调用</font></strong></li></ul></li><li><strong><font color="#EA7500">Prepare（准备）</font></strong>  <ul><li><strong><font color="#EA7500">完成图片的解码</font></strong></li></ul></li><li><strong><font color="#EA7500">Commit（提交）</font></strong>  <ul><li><strong><font color="#EA7500">打包<code>Render Tree</code>通过<code>XPC</code>的方式发送给<code>Render Server</code></font></strong></li></ul></li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1s6efvz5gj210809ygmh.jpg"></p><h6 id="APP的整个启动流程"><a href="#APP的整个启动流程" class="headerlink" title="APP的整个启动流程"></a>APP的整个启动流程</h6><ol><li><p><strong><font color="#EA7500">点击图标，创建进程</font></strong>  </p></li><li><p><strong><font color="#EA7500">mmap 主二进制，找到 dyld 的路径</font></strong>  </p></li><li><p><strong><font color="#EA7500">mmap dyld，把入口地址设为<code>_dyld_start</code></font></strong>  </p></li><li><p><strong><font color="#EA7500">重启手机&#x2F;更新&#x2F;下载 App 的第一次启动，会创建启动闭包</font></strong>  </p></li><li><p><strong><font color="#EA7500">把没有加载的动态库 mmap 进来，动态库的数量会影响这个阶段</font></strong>  </p></li><li><p><strong><font color="#EA7500">对每个二进制做 bind 和 rebase，主要耗时在 Page In，影响 Page In 数量的是 objc 的元数据</font></strong>  </p></li><li><p><strong><font color="#EA7500">初始化 objc 的 runtime，由于闭包已经初始化了大部分，这里只会注册 sel 和装载 category</font></strong>  </p></li><li><p><strong><font color="#EA7500">+load 和静态初始化被调用，除了方法本身耗时，这里还会引起大量 Page In</font></strong>  </p></li><li><p><strong><font color="#EA7500">初始化 <code>UIApplication</code>，启动 Main Runloop</font></strong>  </p></li><li><p><strong><font color="#EA7500">执行 <code>will/didFinishLaunch</code>，这里主要是业务代码耗时</font></strong>  </p></li><li><p><strong><font color="#EA7500">Layout，<code>viewDidLoad</code> 和<code> Layoutsubviews</code> 会在这里调用，<code>Autolayout</code> 太多会影响这部分时间</font></strong>  </p></li><li><p><strong><font color="#EA7500">Display，<code>drawRect</code> 会调用</font></strong>  </p></li><li><p><strong><font color="#EA7500">Prepare，图片解码发生在这一步</font></strong>  </p></li><li><p><strong><font color="#EA7500">Commit，首帧渲染数据打包发给 RenderServer，启动结束</font></strong></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-系统C函数的hook</title>
    <link href="/2022/02/01/iOS-C%E5%87%BD%E6%95%B0%E7%9A%84hook/"/>
    <url>/2022/02/01/iOS-C%E5%87%BD%E6%95%B0%E7%9A%84hook/</url>
    
    <content type="html"><![CDATA[<h3 id="fishhook方案"><a href="#fishhook方案" class="headerlink" title="fishhook方案"></a>fishhook方案</h3><p>通过解析<code>bind</code>、<code>lazy_bind</code>、<code>weak_bind</code>可以获取到元组列表，每个元组会告诉我们符号和指针信息，指针信息包括指针位于哪个段以及在段的偏移</p><p>在iOS中，我们使用用变量或类似<code>NSLog()</code>等外部函数并不是直接调用地址，而是在经过bind 或 lazy_bind后才能得到真正的地址。bind或lazy_bind后真正的函数地址记录在 <code>nl_symbol_ptr</code> 或 <code>la_symbol_ptr</code>中，通过符号表可以找到每个函数对应在<code>nl_symbol_ptr</code>或<code>la_symbol_ptr</code>中的地址。fishhook 就是通过查找符号表，找到记录函数指针的地址修改函数指针从而实现C函数的hook。</p><p>bind是在加载镜像的时候就就已经绑定，而lazy_bind是在首次使用时才触发绑定。</p><blockquote><p> lazy_bind是如何实现在首次调用函数时进行bind的呢？</p></blockquote><p>假设张三和李四是同学，老师手里有个名单，这个名单上记录着要参加值日的同学。本来今天应该是李四值日，但是由于打印名单时教务处老师不知道李四的名字，因此打印了班长张三的名字。老师只认名单，因此老师找来张三打扫卫生。但是张三只做了一件事情，就是把名单上的名字改成了李四，并且叫李四来打扫卫生。这样老师以后如果再吩咐打扫卫生的事情时就直接找到了李四。这就是lazy_bind。故事中老师就是我们写的代码，代码只认地址。名单就是<code>la_symbol_ptr</code>，上面记录了值日同学名。张三就是stub机制，它只是起到了辅助作用。而李四则是真正的外部函数，需要真正执行的函数。</p><h3 id="动态库C函数hook"><a href="#动态库C函数hook" class="headerlink" title="动态库C函数hook"></a>动态库C函数hook</h3><p>除了<code>fishhook</code>外，笔者也有一种C函数的静态hook方式，相比于<code>fishhook</code>，此方案不存在耗时的查找比对操作。下面我将介绍这种比较特殊的方案：基于动态库的C函数hook </p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1dv8sqwtvj20xc0fjmyr.jpg"></p><p><strong>Step1</strong>: 首先在主工程中定义一个同名同参同返回的函数，这样在<code>ld64</code>链接时会认为<code>func1</code>和<code>func2</code> 中用到的<code>NSLog</code>是我们自定义的函数，这样就不会跟系统库的函数进行匹配，<code>NSLog</code>也就不会被标记为需要<code>bind</code>的函数。</p><p><strong>Step2</strong>: 在我们自定义的<code>NSLog</code>内部，我们调用自定义动态库的中间函数<code>MyNSLog</code>，这一步是为了能够调用到真正的<code>NSLog</code></p><p><strong>Step3</strong>: 由于动态库中我们没有自定义<code>NSLog</code>去“欺骗”ld64，因此动态中的<code>NSLog</code>会去调用真正的系统函数。</p><p>到这里可能有同学会问，“难道动态库的<code>NSLog</code>不存在重新调用到主程序的<code>NSLog</code>函数的风险吗？那样岂不是会死循环？”</p><p>不会的。因为动态库是具备编译和链接过程的产物。经过链接时，在二进制文件中就已经写定了<code>NSLog</code>  <code>bind</code>到系统库中的<code>NSLog</code>了，因此在启动阶段<code>dyld</code>不会“违抗”二进制的命令执行到主程序的<code>NSLog</code>。</p><p>但是由于侵入性较强，仅对部分需要<strong>同步启动</strong>用到的函数使用。<code>fishhook</code> 还是项目中最主要的使用方式。</p>]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>dyld 2 和 dyld 3 有哪些区别? 以及iOS15上dyld的变化</title>
    <link href="/2022/01/01/dyld%202%20%E5%92%8C%20dyld%203%20%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%20%E4%BB%A5%E5%8F%8AiOS15%E4%B8%8Adyld%E7%9A%84%E5%8F%98%E5%8C%96/"/>
    <url>/2022/01/01/dyld%202%20%E5%92%8C%20dyld%203%20%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB%20%E4%BB%A5%E5%8F%8AiOS15%E4%B8%8Adyld%E7%9A%84%E5%8F%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="dyld-2-和-dyld-3-有哪些区别-以及iOS15上dyld的变化"><a href="#dyld-2-和-dyld-3-有哪些区别-以及iOS15上dyld的变化" class="headerlink" title="dyld 2 和 dyld 3 有哪些区别? 以及iOS15上dyld的变化"></a>dyld 2 和 dyld 3 有哪些区别? 以及iOS15上dyld的变化</h3><p>dyld 是动态加载器，它主要用于动态库的链接和程序启动加载工作，它目前有两个主要版本：dyld 2 和 dyld 3。</p><p><strong>dyld 2</strong></p><p><a href="https://github.com/opensource-apple/dyld/tree/master/src" title="dyld开源地址">dyld2</a> 从 iOS 3.1 开始引入，一直到 iOS 12 被 dyld 3 全面代替。它经过了很多次版本迭代，我们现在常见的特性比如 ASLR，Code Sign，Shared Cache 等技术，都是在 dyld 2 中引入的。dyld 2 的执行流程是这样的：</p><p><img src="http://cdn.zhangferry.com/Images/20220104235847.png"></p><ul><li>解析 <code>mach-o</code> 头文件，找到依赖库，依赖库又可能有别的依赖，这里会进行递归分析，直到获得所有 dylib 的完整图。这里数据庞大，需要进行大量的处理；</li><li>映射所有 <code>mach-o</code> 文件，将它们放入地址空间；</li><li>执行符号查找，若你的程序使用 <code>printf</code> 函数，将会查找 <code>printf</code> 是否在库系统中，然后我们找到它的地址，将它复制到你的程序中的函数指针上；</li><li>进行 bind 和 rebase，修复内部和外部指针；</li><li>运行一些初始化任务，像是加载 category、load 方法等；</li><li>执行 main；</li></ul><p><strong>dyld 3</strong></p><p>dyld 3 在 2017 年就被引入至 iOS 11，当时主要用来优化系统库。现在，在 iOS 13 中它也将用于启动第三方 APP，完全替代 dyld 2。</p><p>dyld 3 最大的特点就是引入了启动闭包，闭包里包含了启动所需要的缓存信息，而且这个闭包在进程外就完成了。在打开 APP 时，实际上已经有不少工作都完成了，这会使 dyld 的执行更快。</p><p>最重要的特性就是启动闭包，闭包里包含了启动所需要的缓存信息，从而提高启动速度。下图是 dyld 2 和 dyld 3 的执行步骤对比：</p><p><img src="http://cdn.zhangferry.com/Images/20220105001119.png"></p><p>dyld 3 的执行步骤分两大步，以图中虚线隔开，虚线以上进程外执行，以下进程创建时执行：</p><ul><li>前 3 步查找依赖和符号相对耗时，且涉及一些安全问题，所以将这些信息做成缓存闭包写入磁盘里，对应地址：<code>tmp/com.apple.dyld</code>。闭包会在重启手机&#x2F;更新&#x2F;下载 App 的首启等时机创建。</li><li>进程启动时，读取闭包并验证闭包有效性。</li><li>后面步骤同 dyld 2</li></ul><h3 id="iOS-15-的LC-DYLD-CHAINED-FIXUPS"><a href="#iOS-15-的LC-DYLD-CHAINED-FIXUPS" class="headerlink" title="iOS 15 的LC_DYLD_CHAINED_FIXUPS"></a>iOS 15 的LC_DYLD_CHAINED_FIXUPS</h3><p>在iOS15 上，APP的<code>rebase</code> &amp; <code>bind</code> 的方式发生了变化。</p><p>如果我们将<code>iOS Deployment Target</code>设置为15的话，通过<code>MachOView</code>查看打包后的Mach-O文件会发现新的二进制上出现了不支持的LC。</p><p><img src="https://upload-images.jianshu.io/upload_images/4642217-76d3f18e9cc92b52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/830/format/webp" alt="img"></p><p>这是由于<code>LC_DYLD_INFO_ONLY</code>被替换成了新增的<code>LC_DYLD_EXPORTS_TRIE</code>和<code>LC_DYLD_CHAINED_FIXUPS</code>。</p><p>文件的变化意味着iOS 15的<code>rebase</code>和<code>bind</code>机制发生了变化。回顾iOS 14及以前，<code>dyld</code>是通过解析压缩字节流实现了<code>rebase</code>和<code>bind</code>。解析压缩字节会告诉<code>dyld</code> 整个二进制文件中有哪些地址需要修正，以及在<code>bind</code>时每个地址是为哪个外部符号预留。那iOS 15 <code>dyld</code>是如何进行过修正的呢？接下来我们探索下<code>dyld</code>。</p><p> 前段时间听到有同学讨论iOS 15 <code>dyld3</code> 更新为<code>dyld4</code>了。笔者无法确定苹果是否偷偷地升级了<code>dyld</code>，但是从蛛丝马迹中可以看出来<code>dyld</code> 确实是有变化，例如在<code>instrument</code> 中我们可以看到部分函数的命名空间变成了<code>dyld4</code>。还有就是一些API的调用上发生了一些变化，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">let header:UnsafePointer<span class="hljs-tag">&lt;<span class="hljs-name">mach_header</span>&gt;</span> = _dyld_get_image_header(0)<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在iOS 15系统之前通过索引获取<code>header</code>时，如果<code>index == 0</code>，返回的是可执行程序的<code>header</code>。但是在iOS 15中，<code>index == 0</code>获取到的却是系统库。当然这些变化对我们的业务代码可能还不足以产生影响，但是可以说明<code>dyld</code> 确定是有改动。那<code>LC_DYLD_CHAINED_FIXUPS</code>是<code>dyld</code>的新特性吗？我的答案是否定的。因为从<code>dyld3</code>的<code>dyld-852.2</code>版本中可以看到<code>LC_DYLD_CHAINED_FIXUPS</code>早就预埋在dyld中了，只不过在<code>iOS Deployment Target == 15</code>时引起Mach-O文件变化后，才能进入相应的代码分支。</p><h3 id="iOS15上如何让你的应用启动更快？"><a href="#iOS15上如何让你的应用启动更快？" class="headerlink" title="iOS15上如何让你的应用启动更快？"></a>iOS15上如何让你的应用启动更快？</h3><p>在iOS 15中，原本用于rebase &amp; bind 的压缩字节流被替换，取而代之的是fixup-chains(链表结构)。在iOS 启动时，dyld 先判断是否存在fixup-chains，如果存在fixup-chains 则按照fixup-chains的方式进行解析，否则还是按照压缩字节流的方式解析。解析的目的是为了将应用程序的地址进行修正。fixup-chains 机制是由三层结构进行存储，分别是segment（段）-&gt; pages(页) -&gt; fixup-chains(指针链表) 组成。LC_DYLD_CHAINED_FIXUPS所指向的数据会告诉我们有多少segments，每个segment的信息又会告诉我们这个segment有多少pages，以及每个page 的fixup-chains在哪里。 而 fixup-chains中的指针指向了当前page中每一个需要rebase 或者 bind的地址，这些地址中存储的数据并非像iOS 15之前那样都是0x00，而是有一定格式的具有一定意义的8字节数据。而这短短的8字节数据被按照不同的结构体拆分成多个bit，每个或连续几个bit都具有其特殊的含义用于推断rebase 或 bind 所需要的一切信息。iOS 15废除了lazy_bind(weak_bind仍然保留)，由于rebase和bind 被整合为一个链表，因此遍历一次链表即可完成一个page所需的rebase和bind。</p><p><strong>那fixup-chains为什么能加快启动呢？</strong></p><p>因为在iOS 15以前，rebase和bind的信息在压缩字节流中是分别存储的。这就意味着，在启动时dyld在做rebase时会先遍历一遍rebase压缩字节流所记录的地址进行地址修改，假设为N次page fault，由于经过rebase 的page 是被写入数据的dirty page，因此不会被释放，iOS 会通过压缩的方式优化最近没有使用到的dirty page。然后在进行bind时，又遍历bind压缩字节流所记录的那些地址进行修改，假设需要bind M个page。那么在N和M这两个Pages集合中可能存在很多重叠，这就造成了二次遍历，并且iOS可能对其中某些dirty page做了压缩优化。在这种情况下，bind时就需要对这些重叠的pages做解压操作。而fixup-chains很巧妙地解决了这个问题，因为同一个page的rebase和bind整合成一个链表，同时进行这两种操作，这样就不会存在重复遍历相同的page，也不会存在解压的问题。</p><p><strong>疑问</strong></p><p>fixup-chains 会减少page falut次数吗？：不会，依旧是<code>M</code> ∪<code>N</code></p><p>有人问这个算不算iOS 帮我们做了二进制重排？：完全是两回事。虽然都提到了page fault，但是阶段是不同的。</p><p><a href="https://easeapi.com/blog/blog/83-ios13-dyld3.html" title="iOS 13中dyld 3的改进和优化">iOS 13中dyld 3的改进和优化</a></p><p><a href="https://www.yotrolz.com/posts/c2aae680/" title="iOS dyld 前世今生">iOS dyld 前世今生</a></p><p><a href="https://www.jianshu.com/p/6ff72443377b">从野指针探测到对iOS 15 bind 的探索</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Swift-weak的实现</title>
    <link href="/2021/09/01/Swift-weak%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/09/01/Swift-weak%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>在Swift中, <code>SideTable</code> 是针对有需要的对象而创建，系统会为目标对象分配一块新的内存来保存该对象额外的信息。 因为这不是对象必须的内容，所以这个 <code>SideTable</code> 可有可无。对象会有一个指向 <code>SideTable</code> 的指针，同时 <code>SideTable</code> 也有一个指回原对象的指针。在实现上为了不额外多占用内存，目前只有在创建弱引用时，会先把对象的引用计数放到新创建的 <code>SideTable</code> 去，再把空出来的空间存放 <code>SideTable</code> 的地址，会通过一个标志位来区分对象是否有 <code>SideTable</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Swift"><span class="hljs-keyword">class</span> <span class="hljs-title class_">JYObject</span>&#123;<br>    <span class="hljs-keyword">var</span> age :<span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">18</span><br>    <span class="hljs-keyword">var</span> name:<span class="hljs-type">String</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;JY&quot;</span><br>&#125;<br> <br>  <span class="hljs-keyword">var</span> t <span class="hljs-operator">=</span> <span class="hljs-type">JYObject</span>()<br>    <br>  <span class="hljs-keyword">weak</span> <span class="hljs-keyword">var</span> t2 <span class="hljs-operator">=</span> t<br>    <br>  <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----&quot;</span>)<br></code></pre></td></tr></table></figure><p>我们在<code>print</code>处打上断点，查看t2对象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C">(lldb) po t2<br>▿ Optional&lt;JYObject&gt;<br>  ▿ some : &lt;JYObject: <span class="hljs-number">0x6000001a9710</span>&gt;<br><br>(lldb) x/<span class="hljs-number">8</span>gx  <span class="hljs-number">0x6000001a9710</span><br><span class="hljs-number">0x6000001a9710</span>: <span class="hljs-number">0x0000000100491e18</span> <span class="hljs-number">0xc0000c00001f03dc</span><br><span class="hljs-number">0x6000001a9720</span>: <span class="hljs-number">0x0000000000000012</span> <span class="hljs-number">0x000000000000594a</span><br><span class="hljs-number">0x6000001a9730</span>: <span class="hljs-number">0xe200000000000000</span> <span class="hljs-number">0x0000000000000000</span><br><span class="hljs-number">0x6000001a9740</span>: <span class="hljs-number">0x00007efd22b59740</span> <span class="hljs-number">0x000000000000009c</span><br>(lldb) <br></code></pre></td></tr></table></figure><p>通过查看汇编，定义了一个<code>weak</code>变量，编译器自动调用了<code>swift_weakInit</code>函数，这个函数是由<code>WeakReference</code>调用的。说明<code>weak</code>字段在编译器声明的过程当中自动生成了<code>WeakReference</code>对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">WeakReference *<span class="hljs-title">swift::swift_weakInit</span><span class="hljs-params">(WeakReference *ref, HeapObject *value)</span> </span>&#123;<br>  ref-&gt;<span class="hljs-built_in">nativeInit</span>(value);<br>  <span class="hljs-keyword">return</span> ref;<br>&#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nativeInit</span><span class="hljs-params">(HeapObject *object)</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> side = object ? object-&gt;refCounts.formWeakReference() : <span class="hljs-literal">nullptr</span>;<br>    nativeValue.<span class="hljs-built_in">store</span>(<span class="hljs-built_in">WeakReferenceBits</span>(side), std::memory_order_relaxed);<br>  &#125;<br><br><span class="hljs-keyword">template</span> &lt;&gt;<br>HeapObjectSideTableEntry* RefCounts&lt;InlineRefCountBits&gt;::formWeakReference()<br>&#123;<br>    <span class="hljs-comment">// 创建一个 Side Table</span><br>  <span class="hljs-keyword">auto</span> side = <span class="hljs-built_in">allocateSideTable</span>(<span class="hljs-literal">true</span>);<br>  <span class="hljs-keyword">if</span> (side)<br>      <span class="hljs-comment">// 增加一个弱引用</span><br>    <span class="hljs-keyword">return</span> side-&gt;<span class="hljs-built_in">incrementWeak</span>();<br>  <span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 我们来看一下<code>allocateSideTable</code>方法，是如何创建一个<code>Side Table</code>的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">template</span> &lt;&gt;<br>HeapObjectSideTableEntry* RefCounts&lt;InlineRefCountBits&gt;::<span class="hljs-built_in">allocateSideTable</span>(<span class="hljs-type">bool</span> failIfDeiniting)<br>&#123;<br>  <span class="hljs-comment">//1.拿到原有的引用计数</span><br>  <span class="hljs-keyword">auto</span> oldbits = refCounts.<span class="hljs-built_in">load</span>(SWIFT_MEMORY_ORDER_CONSUME);<br>  <br>  <span class="hljs-comment">// 判断是否有SideTable，</span><br>  <span class="hljs-keyword">if</span> (oldbits.<span class="hljs-built_in">hasSideTable</span>()) &#123;<br>    <span class="hljs-comment">// Already have a side table. Return it.</span><br>    <span class="hljs-keyword">return</span> oldbits.<span class="hljs-built_in">getSideTable</span>();<br>  &#125; <br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (failIfDeiniting &amp;&amp; oldbits.<span class="hljs-built_in">getIsDeiniting</span>()) &#123;<br>    <span class="hljs-comment">// Already past the start of deinit. Do nothing.</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// Preflight passed. Allocate a side table.</span><br>  <br>  <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> custom side table allocator</span><br> <br>  <span class="hljs-comment">//2.通过HeapObject创建了一个HeapObjectSideTableEntry实例对象</span><br>  HeapObjectSideTableEntry *side = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HeapObjectSideTableEntry</span>(<span class="hljs-built_in">getHeapObject</span>());<br> <br>  <span class="hljs-comment">//3.将创建的实例对象地址给了InlineRefCountBits，也就是 RefCountBitsT</span><br>  <span class="hljs-keyword">auto</span> newbits = <span class="hljs-built_in">InlineRefCountBits</span>(side);<br>  <br>  <span class="hljs-keyword">do</span> &#123;<br>    <span class="hljs-keyword">if</span> (oldbits.<span class="hljs-built_in">hasSideTable</span>()) &#123;<br>      <span class="hljs-comment">// Already have a side table. Return it and delete ours.</span><br>      <span class="hljs-comment">// Read before delete to streamline barriers.</span><br>      <span class="hljs-keyword">auto</span> result = oldbits.<span class="hljs-built_in">getSideTable</span>();<br>      <span class="hljs-keyword">delete</span> side;<br>      <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (failIfDeiniting &amp;&amp; oldbits.<span class="hljs-built_in">getIsDeiniting</span>()) &#123;<br>      <span class="hljs-comment">// Already past the start of deinit. Do nothing.</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>     <br>    <span class="hljs-comment">// 将原有的引用计数存储</span><br>    side-&gt;<span class="hljs-built_in">initRefCounts</span>(oldbits);<br>     <br>  &#125; <span class="hljs-keyword">while</span> (! refCounts.<span class="hljs-built_in">compare_exchange_weak</span>(oldbits, newbits,<br>                                             std::memory_order_release,<br>                                             std::memory_order_relaxed));<br>  <span class="hljs-keyword">return</span> side;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结一下上面所做的事情</p><p>1.拿到原有的引用计数<br>2.通过HeapObject创建了一个HeapObjectSideTableEntry实例对象<br>3.将创建的实例对象地址给了<code>InlineRefCountBits</code>，也就是 RefCountBitsT。</p></blockquote><p>构造完 <code>Side Table</code> 以后，对象中的 <code>RefCountBitsT</code> 就不是原来的引用计数了，而是一个指向 <code>Side Table</code> 的指针，然而由于它们实际都是 <code>uint64_t</code>，因此需要一个方法来区分。区分的方法我们可以来看 <code>InlineRefCountBits</code> 的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//弱引用</span><br><span class="hljs-function">LLVM_ATTRIBUTE_ALWAYS_INLINE</span><br><span class="hljs-function">  <span class="hljs-title">RefCountBitsT</span><span class="hljs-params">(HeapObjectSideTableEntry* side)</span></span><br><span class="hljs-function">    : bits((reinterpret_cast&lt;BitsType&gt;(side) &gt;&gt; Offsets::SideTableUnusedLowBits)</span><br><span class="hljs-function">           | (BitsType(<span class="hljs-number">1</span>) &lt;&lt; Offsets::UseSlowRCShift)</span><br><span class="hljs-function">           | (BitsType(<span class="hljs-number">1</span>) &lt;&lt; Offsets::SideTableMarkShift))</span><br><span class="hljs-function">  &#123;</span><br>    <span class="hljs-built_in">assert</span>(refcountIsInline);<br>  &#125;<br></code></pre></td></tr></table></figure><blockquote><p>在弱引用方法中把创建出来的地址做了偏移操作然后存放到了内存当中。</p><p><code>SideTableUnusedLowBits</code> &#x3D; 3，所以，在这个过程中，传进来的<code>side</code>往右移了 3 位，下面的两个是 62 位和 63 位标记成 1</p></blockquote><p>我们接着来看一下 <code>HeapObjectSideTableEntry</code> 的结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">HeapObjectSideTableEntry</span> &#123;<br>  <span class="hljs-comment">// <span class="hljs-doctag">FIXME:</span> does object need to be atomic?</span><br>  std::atomic&lt;HeapObject*&gt; object;<br>  SideTableRefCounts refCounts;<br><br>  <span class="hljs-keyword">public</span>:<br>  <span class="hljs-built_in">HeapObjectSideTableEntry</span>(HeapObject *newObject)<br>    : <span class="hljs-built_in">object</span>(newObject), <span class="hljs-built_in">refCounts</span>()<br>  &#123; &#125;<br></code></pre></td></tr></table></figure><p>我们来尝试还原一下 拿到弱引用计数 </p><p><code>0xc0000c00001f03dc</code>62位和63位清0得到 <code>HeapObjectSideTableEntry</code> 实例对象的地址<code>0xC00001F03DC</code></p><p>它既然是右移 3 位，那么我左移 3 位把它还原，<code>HeapObjectSideTableEntry</code>左移三位 得到<code>0x10062AFE0</code></p><p><img src="https://gitee.com/zhangferry/Images/raw/master/iOSWeeklyLearning/20220302155825.png"></p><ul><li><code>0x6000001a9710</code> 就是实例对象的地址。</li><li><code>0x0000000000000002</code>就是弱引用计数。<br>这里弱引用为<code>2</code>的原因是因为<code>SideTableRefCountBits</code>初始化的时候从<code>1</code>开始.</li></ul><p> <code>Side Table</code>的生命周期与对象是分离的，当强引用计数为 0 时，只有 <code>HeapObject</code> 被释放了，并没有释放<code>Side Table</code>，只有所有的 <code>weak</code> 引用者都被释放了或相关变量被置 <code>nil</code> 后，<code>Side Table</code> 才能得以释放</p>]]></content>
    
    
    <categories>
      
      <category>Swift</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-OOM产生的原因</title>
    <link href="/2021/08/08/iOS-OOM%E5%8E%9F%E7%90%86/"/>
    <url>/2021/08/08/iOS-OOM%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h4 id="什么是OOM"><a href="#什么是OOM" class="headerlink" title="什么是OOM"></a>什么是<code>OOM</code></h4><p><code>out-of-memory</code> 内存超过限制，iOS的<code>Jetsam</code>机制造成的一种<code>Crash</code>，这种另类<code>Crash</code>，通过通过<code>Signal</code>捕获等方法无法捕获</p><h4 id="什么又是FOOM"><a href="#什么又是FOOM" class="headerlink" title="什么又是FOOM"></a>什么又是<code>FOOM</code></h4><p><code>Foreground-out-of-memory</code> App在前台因消耗内存过多而引起的系统强杀</p><h4 id="什么是JetSam机制"><a href="#什么是JetSam机制" class="headerlink" title="什么是JetSam机制"></a>什么是<code>JetSam</code>机制</h4><p><code>JetSam</code>机制是操作系统为了控制内存资源过度所建立的一种管理机制，<code>JetSam</code>是一个独立的进程，每一个进程都会有一个阈值，一旦超过这个值，<code>JetSam</code>就会杀死这个进程，设备的内存是有限制的，并不是无限大的，所以内存资源非常重要。系统进程及用户使用的其他app的进程都会争抢这个资源。由于iOS不支持交换空间，一旦触发低内存事件，<code>Jetsam</code>就会尽可能多的释放应用占用的内存，这样在iOS系统上出现系统内存不足时，应用就会被系统终止。</p><h4 id="交换空间"><a href="#交换空间" class="headerlink" title="交换空间"></a>交换空间</h4><p>物理内存不够使用该怎么办呢？像一些桌面操作系统，会有内存交换空间，在window上称为虚拟内存。它的机制是，在需要时能将物理内存中的一部分交换到硬盘上去，利用硬盘空间扩展内存空间。</p><h4 id="iOS不支持交换空间"><a href="#iOS不支持交换空间" class="headerlink" title="iOS不支持交换空间"></a>iOS不支持交换空间</h4><p>但iOS并不支持交换空间，大多数移动设备都不支持交换空间。移动设备的大容量存储器通常是闪存，它的读写速度远远小于电脑所使用的硬盘，这就导致在移动设备上就算使用了交换空间，也并不能提升性能。其次，移动设备的容量本身就经常短缺、内存的读写寿命也有限，所以不适合拿闪存来做内存交换</p><h4 id="典型app内存类型"><a href="#典型app内存类型" class="headerlink" title="典型app内存类型"></a>典型app内存类型</h4><p>当内存不足的时候，系统会按照一定策略来腾出更多空间供使用，比较常见的做法是将一部分低优先级的数据挪到磁盘上，这个操作称为Page Out。之后当再次访问到这块数据的时候，系统会负责将它重新搬回内存空间中，这个操作称为Page In。</p><h4 id="Clean-Memory"><a href="#Clean-Memory" class="headerlink" title="Clean Memory"></a>Clean Memory</h4><p>Clean Memory是指那些可以用以Page Out的内存，只读的内存映射文件，或者是App所用到的frameworks。每个frameworks都有_DATA_CONST段，通常他们都是Clean的，但如果用runtime进行swizzling，那么他们就会变Dirty。</p><h4 id="Dirty-Memory"><a href="#Dirty-Memory" class="headerlink" title="Dirty Memory"></a>Dirty Memory</h4><p>Dirty Memory是指那些被App写入过数据的内存，包括所有堆区的对象、图像解码缓冲区，同时，类似Clean memory，也包括App所用到的frameworks。每个framework都会有_DATA段和_DATA_DIRTY段，它们的内存是Dirty的。</p><p>值得注意的是，在使用framework的过程中会产生Dirty Memory，使用单例或者全局初始化方法是减少Dirty Memory不错的方法，因为单例一旦创建就不会销毁，全局初始化方法会在类加载时执行。</p><h4 id="Compressed-Memory"><a href="#Compressed-Memory" class="headerlink" title="Compressed Memory"></a>Compressed Memory</h4><p>由于闪存容量和读写寿命的限制，iOS 上没有交换空间机制，取而代之使用Compressed memory。</p><p>Compressed memory是在内存紧张时能够将最近使用过的内存占用压缩至原有大小的一半以下，并且能够在需要时解压复用。它在节省内存的同时提高了系统的响应速度，特点总结起来如下：</p><p>Shrinks memory usage 减少了不活跃内存占用 Improves power efficiency 改善电源效率，通过压缩减少磁盘IO带来的损耗 Minimizes CPU usage 压缩&#x2F;解压十分迅速，能够尽可能减少 CPU 的时间开销 Is multicore aware 支持多核操作 例如，当我们使用Dictionary去缓存数据的时候，假设现在已经使用了3页内存，当不访问的时候可能会被压缩为1页，再次使用到时候又会解压成3页。</p><p>本质上，<code>Compressed memory</code>也是<code>Dirty memory</code>。<br>因此， <code>memory footprint = dirty size + compressed size</code> ，这也就是我们需要并且能够尝试去减少的内存占用。</p><h4 id="出现OOM前一定会出现Memory-Warning么？"><a href="#出现OOM前一定会出现Memory-Warning么？" class="headerlink" title="出现OOM前一定会出现Memory Warning么？"></a>出现OOM前一定会出现<code>Memory Warning</code>么？</h4><p>答案是不一定，有可能瞬间申请了大量内存，而恰好此时主线程在忙于其他事情，导致可能没有经历过Memory Warning就发生了OOM。当然即便出现了多次Memory Warning后，也不见得会在最后一次Memory Warning的几秒钟后出现OOM。之前做extension开发的时候，就经常会出现Memory Warnning，但是不会出现OOM，再操作一两分钟后，才出现OOM，而在这一两分钟内，没有再出现过Memory Warning。</p><p>当然在内存警告时，处理内存，可以在一定程度上避免出现OOM。</p><h4 id="开始分析系统的JetSam"><a href="#开始分析系统的JetSam" class="headerlink" title="开始分析系统的JetSam"></a>开始分析系统的<code>JetSam</code></h4><p><code>bsd_init</code>当中找到初始化<code>JetSam</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// iOS上独有的特性，内存和进程的休眠的常驻监控线程</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> CONFIG_FREEZE   <span class="hljs-comment">// 这个宏是内核会对进程进行冷冻而不是kill掉</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CONFIG_MEMORYSTATUS</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">error</span> <span class="hljs-string">&quot;CONFIG_FREEZE defined without matching CONFIG_MEMORYSTATUS&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-comment">/* Initialise background freezing */</span><br>    <span class="hljs-built_in">bsd_init_kprintf</span>(<span class="hljs-string">&quot;calling memorystatus_freeze_init\n&quot;</span>);<br>    <span class="hljs-built_in">memorystatus_freeze_init</span>(); <span class="hljs-comment">//从内核中开启优先级最高的线程来监控整个系统的内存情况</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">//iOS独有，JetSAM（即低内存事件的常驻监控线程）</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> CONFIG_MEMORYSTATUS</span><br>    <span class="hljs-comment">/* Initialize kernel memory status notifications */</span><br>    <span class="hljs-built_in">bsd_init_kprintf</span>(<span class="hljs-string">&quot;calling memorystatus_init\n&quot;</span>);<br>    <span class="hljs-built_in">memorystatus_init</span>(); <span class="hljs-comment">//从内核中开启优先级最高的线程来监控整个系统的内存情况</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* CONFIG_MEMORYSTATUS */</span></span><br></code></pre></td></tr></table></figure><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>在内核里面所有的进程都有一个优先级，通过一个数组维护，数组的每一项是一个进程的列表也就是<code>memstat_bucket</code>。这个数组的大小则是<code>JETSAM_PRIORITY_MAX + 1</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MEMSTAT_BUCKET_COUNT (JETSAM_PRIORITY_MAX + 1)</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">memstat_bucket</span> &#123;<br>    <span class="hljs-built_in">TAILQ_HEAD</span>(, proc) list; <span class="hljs-comment">//一个TAILQ_HEAD的双向链表用来存放优先级</span><br>    <span class="hljs-type">int</span> count; <span class="hljs-comment">//进程个数</span><br>    <span class="hljs-type">int</span> relaunch_high_count;<br>&#125; <span class="hljs-type">memstat_bucket_t</span>;<br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">memstat_bucket_t</span> memstat_bucket[MEMSTAT_BUCKET_COUNT]; <span class="hljs-comment">//优先级队列(里面包含不同优先级的结构)    </span><br></code></pre></td></tr></table></figure><p>在这里可以看到优先级数字，其中<code>SpringBoard</code>就<code>JETSAM_PRIORITY_HOME</code>,后台应用程序为<code>JETSAM_PRIORITY_BACKGROUND</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb50ee7d685846d1ad3b6ac2c1496a4e~tplv-k3u1fbpfcp-zoom-1.image" alt="imagepng"></p><h4 id="回到-memorystatus-init"><a href="#回到-memorystatus-init" class="headerlink" title="回到 memorystatus_init"></a>回到 <code>memorystatus_init</code></h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">jetsam_threads = zalloc<span class="hljs-constructor">_permanent(<span class="hljs-params">sizeof</span>(<span class="hljs-params">struct</span> <span class="hljs-params">jetsam_thread_state</span>)</span><span class="hljs-operator"> *</span><br><span class="hljs-operator"></span><br><span class="hljs-operator"></span>max_jetsam_threads, <span class="hljs-constructor">ZALIGN(<span class="hljs-params">struct</span> <span class="hljs-params">jetsam_thread_state</span>)</span>);<br><br><br><span class="hljs-comment">/* Initialize all the jetsam threads */</span><br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; max_jetsam_threads; i++) &#123;<br><br><span class="hljs-comment">// max_jetsam_threads 性能差为1个 ，普通为3个</span><br>jetsam_threads<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.inited = FALSE;<br>jetsam_threads<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>.index = i;<br><br><br><span class="hljs-comment">//这些线程的优先级是内核所能分配的最高级95 MAXPRI_KERNEL  (XNU的线程优先级为0-127)</span><br>result = kernel<span class="hljs-constructor">_thread_start_priority(<span class="hljs-params">memorystatus_thread</span>, NULL, 95 <span class="hljs-operator">/</span><span class="hljs-operator">*</span> MAXPRI_KERNEL <span class="hljs-operator">*</span><span class="hljs-operator">/</span>, &amp;<span class="hljs-params">jetsam_threads</span>[<span class="hljs-params">i</span>].<span class="hljs-params">thread</span>)</span>;<br><span class="hljs-keyword">if</span> (result != KERN_SUCCESS) &#123;<br>     panic(<span class="hljs-string">&quot;Could not create memorystatus_thread %d&quot;</span>, i);<br>&#125;<br>     thread<span class="hljs-constructor">_deallocate(<span class="hljs-params">jetsam_threads</span>[<span class="hljs-params">i</span>].<span class="hljs-params">thread</span>)</span>;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="来到-memorystatus-thread"><a href="#来到-memorystatus-thread" class="headerlink" title="来到 memorystatus_thread"></a>来到 <code>memorystatus_thread</code></h4><p>系统中会有一个线程专门来管理内存状态，当内存出现问题或者压力过大时，将会通过一些方法来干掉APP回收内存</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bbac5549ff7249d4a21f8c009ef12be8~tplv-k3u1fbpfcp-zoom-1.image" alt="imagepng"></p><p><code>memorystatus_action_needed()</code>是触发OOM的核心判断条件。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f9f965fa5194490b1a56a272bd7f2d2~tplv-k3u1fbpfcp-zoom-1.image" alt="imagepng"></p><h4 id="我们来到-is-reason-thrashing"><a href="#我们来到-is-reason-thrashing" class="headerlink" title="我们来到 is_reason_thrashing"></a>我们来到 <code>is_reason_thrashing</code></h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a731f7cd91614b75b3c0cf852819ccea~tplv-k3u1fbpfcp-zoom-1.image" alt="imagepng"></p><h4 id="memorystatus-action-needed为true来到了Highwater"><a href="#memorystatus-action-needed为true来到了Highwater" class="headerlink" title="memorystatus_action_needed为true来到了Highwater"></a><code>memorystatus_action_needed</code>为true来到了<code>Highwater</code></h4><p>来到这里证明当前内存紧张，来到<code>memorystatus_act_on_hiwat_processes</code></p><h4 id="memorystatus-act-on-hiwat-processes"><a href="#memorystatus-act-on-hiwat-processes" class="headerlink" title="memorystatus_act_on_hiwat_processes"></a><code>memorystatus_act_on_hiwat_processes</code></h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/539a3a8aed30452e9f5d3e8610538d97~tplv-k3u1fbpfcp-zoom-1.image" alt="imagepng"></p><p>则会调用<code>memorystatus_kill_hiwat_proc</code></p><ol><li>优先级队列里面取出优先级最低的进程</li><li>while循环查找进程的内存是否高于阈值</li><li>如果高于则通过<code>memorystatus_do_kill</code>杀掉这个进程，并结束循环</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37ebcdf7faa64f049020f209fd3fc070~tplv-k3u1fbpfcp-zoom-1.image" alt="imagepng"></p><p>如果经过了<code>Highwater</code>还是没有办法结束进程，将来到<code>memorystatus_act_aggressive</code></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d74e199fadb4df0ad63134f4c79ec4e~tplv-k3u1fbpfcp-zoom-1.image" alt="imagepng"></p><h4 id="memorystatus-act-aggressive-也就是我们所经常遇到的OOM"><a href="#memorystatus-act-aggressive-也就是我们所经常遇到的OOM" class="headerlink" title="memorystatus_act_aggressive 也就是我们所经常遇到的OOM"></a><code>memorystatus_act_aggressive</code> 也就是我们所经常遇到的OOM</h4><p>这部分代码太多 我就贴关键的代码了</p><h4 id="如果上面memorystatus-act-aggressive函数没有杀死任何进程，那么就需要通过LRU来杀死Jetsam队列中的第一个进程"><a href="#如果上面memorystatus-act-aggressive函数没有杀死任何进程，那么就需要通过LRU来杀死Jetsam队列中的第一个进程" class="headerlink" title="如果上面memorystatus_act_aggressive函数没有杀死任何进程，那么就需要通过LRU来杀死Jetsam队列中的第一个进程"></a>如果上面<code>memorystatus_act_aggressive</code>函数没有杀死任何进程，那么就需要通过<code>LRU</code>来杀死<code>Jetsam</code>队列中的第一个进程</h4><h3 id="总结-系统触发OOM的过程"><a href="#总结-系统触发OOM的过程" class="headerlink" title="总结 - 系统触发OOM的过程"></a>总结 - 系统触发OOM的过程</h3><ol><li><code>JetSam</code>线程初始化完毕，从外部接受到有内存压力</li><li>如果接收到的内存压力是当前物理内存达到限制时，则触发<code>per-process-limit</code>类型的<code>OOM</code>，然后退出流程</li><li>如果接收到内存压力是其他类型时，唤醒<code>JetSam</code>线程，判断当前可用内存紧张则进入<code>OOM</code>逻辑</li><li>首先遍历优先级最低的进程，判断进程是否高于阈值，如果没有高于阈值，则查找比当前优先级高一级的进程，直到找到后，触发<code>high-water</code>类型<code>OOM</code></li><li>如果没有触发<code>high-water</code> ，那就先回收一个优先级较低的进程或者标记为随时可回收的进程</li><li>当所有低优先级进程和随时可回收的进程都被杀掉后，如果<code>memorystatus_available_pages</code>可用内存依然低于正常水平，那就开始杀掉后台进程，每杀掉一个后台进程，则判断一下<code>memorystatus_available_pages</code>可用内存是否还是低于正常水平，如果已经恢复到正常，则挂起线程，等待唤醒</li><li>当所有后台进程都被杀死后，可用内存还是低于正常，那就开始杀掉前台的进程，挂起线程，等待唤醒</li><li>如果上面没有杀掉任何进程，就通过<code>LRU</code>杀死<code>JetSam</code>队列中的第一个进程，挂起线程，等待唤醒</li></ol><h4 id="Matrix如何检测OOM？"><a href="#Matrix如何检测OOM？" class="headerlink" title="Matrix如何检测OOM？"></a><code>Matrix</code>如何检测<code>OOM</code>？</h4><p><code>Matrix</code>采用的是排除法，在每次启动<code>Matrix</code>的时候都会调用<code>[MatrixAppRebootAnalyzer checkRebootType];</code></p><p>来看一下<code>checkRebootType</code>方法中有什么</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs awk">+ (void)checkRebootType &#123;<br>    <span class="hljs-keyword">if</span> ([MatrixDeviceInfo isBeingDebugged]) &#123; <span class="hljs-regexp">//</span> 是否在DEBUG<br>        MatrixInfo(@<span class="hljs-string">&quot;app is being debugged&quot;</span>);<br>        MatrixAppRebootInfo *info = [MatrixAppRebootInfo sharedInstance];<br>        info.isAppCrashed = NO;<br>        info.isAppQuitByExit = NO;<br>        info.isAppQuitByUser = NO;<br>        info.isAppWillSuspend = NO;<br>        info.isAppEnterBackground = NO;<br>        info.isAppEnterForeground = NO;<br>        info.isAppBackgroundFetch = NO;<br>        info.isAppSuspendKilled = NO;<br>        info.isAppMainThreadBlocked = NO;<br>        info.dumpFileName = @<span class="hljs-string">&quot;&quot;</span>;<br>        info.userScene = @<span class="hljs-string">&quot;&quot;</span>;<br>        [info saveInfo];<br>        return;<br>    &#125;<br><br>    MatrixAppRebootInfo *info = [MatrixAppRebootInfo sharedInstance];<br><br>    <span class="hljs-keyword">if</span> (info.isAppCrashed) &#123;<br>        <span class="hljs-regexp">//</span> App是否发生了普通的Crash<br>        s_rebootType = MatrixAppRebootTypeNormalCrash;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (info.isAppQuitByUser) &#123;<br>        <span class="hljs-regexp">//</span> 是否用户主动退出应用<br>        s_rebootType = MatrixAppRebootTypeQuitByUser;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (info.isAppQuitByExit) &#123;<br>        <span class="hljs-regexp">//</span> 是否调用了<span class="hljs-keyword">exit</span>相关的函数<br>        s_rebootType = MatrixAppRebootTypeQuitByExit;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (info.isAppWillSuspend || info.isAppBackgroundFetch) &#123;<br>        <span class="hljs-regexp">//</span> App是否挂起Suspend或者执行了BackgroundFetch<br>        <span class="hljs-keyword">if</span> (info.isAppSuspendKilled) &#123;<br>            s_rebootType = MatrixAppRebootTypeAppSuspendCrash;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            s_rebootType = MatrixAppRebootTypeAppSuspendOOM;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([MatrixAppRebootAnalyzer isAppChange]) &#123;<br>        <span class="hljs-regexp">//</span> App的版本是否发生了改变<br>        s_rebootType = MatrixAppRebootTypeAPPVersionChange;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([MatrixAppRebootAnalyzer isOSChange]) &#123;<br>        <span class="hljs-regexp">//</span> 手机系统是否升级了<br>        s_rebootType = MatrixAppRebootTypeOSVersionChange;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ([MatrixAppRebootAnalyzer isOSReboot]) &#123;<br>        <span class="hljs-regexp">//</span> 手机是否重启了<br>        s_rebootType = MatrixAppRebootTypeOSReboot;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (info.isAppEnterBackground) &#123;<br>        <span class="hljs-regexp">//</span> App是否处于后台<br>        s_rebootType = MatrixAppRebootTypeAppBackgroundOOM;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (info.isAppEnterForeground) &#123;<br>        <span class="hljs-regexp">//</span> App是否处于前台<br>        <span class="hljs-keyword">if</span> (info.isAppMainThreadBlocked) &#123;<br>            <span class="hljs-regexp">//</span> 主线程是否卡死了 <br>            s_rebootType = MatrixAppRebootTypeAppForegroundDeadLoop;<br>            s_lastDumpFileName = info.dumpFileName;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-regexp">//</span> 触发Foreground OOM<br>            s_rebootType = MatrixAppRebootTypeAppForegroundOOM;<br>            s_lastDumpFileName = @<span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        s_rebootType = MatrixAppRebootTypeOtherReason;<br>    &#125;<br></code></pre></td></tr></table></figure><p>现在所遇到的<code>OOM</code>主要都是<code>FOOM</code>，因为优先级的缘故，App在后台的时候，即使占用内存很少，也有可能被前台应用过多占用内存而被杀死，所以关注的点上还是要在<code>FOOM</code></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/TuGeLe/article/details/104004692">深入了解iOS中的OOM(低内存崩溃)</a></p><p>(<a href="http://www.cocoachina.com/index.php/articles/485753">你真的了解OOM吗？——京东iOS APP内存优化实录</a>)</p><p><a href="https://juejin.cn/post/6844903749836603400">iOS Out-Of-Memory 原理阐述及方案调研</a></p><p><a href="https://wetest.qq.com/lab/view/367.html">iOS微信内存监控</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-编译过程梳理</title>
    <link href="/2021/08/02/iOS-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E6%A2%B3%E7%90%86/"/>
    <url>/2021/08/02/iOS-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E6%A2%B3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="iOS-编译过程梳理"><a href="#iOS-编译过程梳理" class="headerlink" title="iOS 编译过程梳理"></a>iOS 编译过程梳理</h1><p>编译语言在执行的时候，必须先通过编译器生成机器码，机器码可以直接在 CPU 上执行，所以执行效率很高。</p><h2 id="编译器的概述"><a href="#编译器的概述" class="headerlink" title="编译器的概述"></a>编译器的概述</h2><p>编译器的作用是把我们的高级语言转换成机器可以识别的机器码，经典的设计结构如下：</p><p> <img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1dwrp77ruj20ki03z0sn.jpg"></p><ul><li>前端（Frontend）：语法分析，语义分析和生成中间代码。在这个过程中，也会对代码进行检查，如果发现出错的或需要警告的会标注出来。</li><li>优化器（Optimizer）：会进行 BitCode 的生成，链接期优化等工作。</li><li>后端（Backend）：针对不同的架构，生成对应的机器码。</li></ul><h2 id="Clang-LLVM-的编译过程"><a href="#Clang-LLVM-的编译过程" class="headerlink" title="Clang + LLVM 的编译过程"></a>Clang + LLVM 的编译过程</h2><ol><li><strong>预处理阶段</strong>：import 头文件替换；macro 宏展开；处理预编译指令</li><li><strong>词法分析</strong>：预处理完成后进入词法分析，将输入的代码转化为一系列符合特定语言的词法单元（token 流）。</li><li><strong>语法分析</strong>：将词法分析得到的 token 流进行语法静态分析（Static Analysis），输出<strong>抽象语法树（AST）</strong>，过程中会校验语法是否错误。</li><li><strong>CodeGen 生成 IR 中间代码</strong>：CodeGen 负责将语法树自顶向下遍历翻译成 <code>LLVM IR</code>，<code>IR</code> 是编译过程中前端的输出后端的输入。</li><li><strong>Optimize 优化 IR</strong>：到这里 LLVM 会做一些优化工作，在 Xcode 的编译设置里可以设置优化级别 -01, -03, -0s，也可以写自己的 Pass，Pass 是 LLVM 优化工作的一个节点，一个节点做些事，一起加起来就构成了 LLVM 完整的优化和转化。附件：<a href="http://llvm.org/docs/WritingAnLLVMPass.html">官方 Pass 教程</a>。</li><li><strong>LLVM Bitcode 生成字节码</strong>：如果开启了 bitcode，苹果会做进一步优化。若有新的后端架构，依旧可以用这份优化过的 bitcode 去生成。</li><li><strong>生成汇编</strong></li><li><strong>生成目标文件</strong></li><li><strong>生成可执行文件</strong></li></ol><h2 id="Xcode-Build-的流程"><a href="#Xcode-Build-的流程" class="headerlink" title="Xcode Build 的流程"></a>Xcode Build 的流程</h2><p>我们在 Xcode 中使用 <strong>Command + B</strong> 或 <strong>Command + R</strong> 时，即完成了一次编译，来看下这个过程做了哪些事情。</p><p>编译过程分为四个步骤：</p><ul><li>预编译（Pre-process）：宏替换、删除注释、展开头文件，产生 .i 文件。</li><li>编译（Compliling）：把前面生成的 .i 文件转化为汇编语言，产生 .s 文件。</li><li>汇编（Asembly）：把汇编语言 .s 文件转化为机器码文件，产生 .0 文件。</li><li>链接（Link）：对 .o 文件中的对于其他库的引用的地方进行引用，生成最后的可执行文件。也包括多个 .o 文件进行 link。</li></ul><p>通过解析 Xcode 编译 log，可以发现 Xcode 是根据 Target 进行编译的。我们可以通过 Xcode 中的 Build Phases、Build Settings 及 Build Rules 来控制编译过程。</p><ul><li>Build Settings：这一栏下是对编译的细节进行设定，包含 build 过程的每个阶段的设置选项（包含编译、链接、代码签名、打包）。</li><li>Build Phases：用于控制从源文件到可执行文件的整个过程，如编译哪些文件，编译过程中执行哪些自定义脚本。例如 CocoaPods 在这里会进行相关配置。</li><li>Build Rules：指定了不同的文件类型该如何编译。一般我们不需要修改这里的内容。如果需要对特定类型的文件添加处理方法，可以在这里添加规则。</li></ul><p>每个 Target 的具体编译过程也可以通过 log 日志获得。大致过程为：</p><ul><li>编译信息写入辅助文件（如Entitlements.plist），创建编译后的文件架构</li><li>写入辅助信息（.hmap 文件）。将项目的文件结构对应表、将要执行的脚本、项目依赖库的文件结构对应表写成文件。</li><li>运行预设的脚本。如 Cocoapods 会在 Build Phases 中预设一些脚本（CheckPods Manifest.lock）。</li><li>编译 .m 文件，生成可执行文件 Mach-O。每次进行了 LLVM 的完整流程：前端（词法分析 - 语法分析 - 生成 IR）、优化器（优化 IR）、后端（生成汇编 - 生成目标文件 - 生成可执行文件）。使用 <code>CompileC</code> 和 <code>clang</code> 命令。 CompileC 是 xcodebuild 内部函数的日志记录表示形式，它是 build.log 文件中有关编译的基本信息来源。</li><li>链接需要的库。如 Foundation.framework，AFNetworking.framework…</li><li>拷贝资源文件到目标包</li><li>编译 storyboard 文件</li><li>链接 storyboard 文件</li><li>编译 Asset 文件。如果使用 Asset.xcassets 来管理图片，这些图片会被编译为机器码，除了 icon 和 launchIamge。</li><li>处理 infoplist</li><li>执行 CocoaPods 脚本，将在编译项目前已编译好的依赖库和相关资源拷贝到包中。</li><li>拷贝 Swift 标准库</li><li>创建 .app 文件并对其签名</li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-线程数量监控</title>
    <link href="/2021/07/01/iOS-%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E7%9B%91%E6%8E%A7/"/>
    <url>/2021/07/01/iOS-%E7%BA%BF%E7%A8%8B%E6%95%B0%E9%87%8F%E7%9B%91%E6%8E%A7/</url>
    
    <content type="html"><![CDATA[<p>在iOS开发中，我们会经常开辟新的线程去做一些事，如何合理的开辟线程，在App开发阶段，监控线程的开辟数量，避免线上发生意外情况。 </p><p>当线程过多或瞬间创建大量子线程(线程爆炸)，就在控制台打印信息，并记录信息。</p><ol><li><p>创建子线程过多，是会造成性能问题的，因为创建线程需要占用内存空间（默认的情况下，主线程占1M,子线程占用512KB）。</p></li><li><p>不合理创建和使用线程，容易引发数据一致性（线程安全）和死锁问题。</p></li></ol><p>因为在iOS中基本上都是使用的<code>p_thread</code>，在<code>Mach</code>层中<code>thread_basic_info</code> 结构体封装了单个线程的基本信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">struct thread_basic_info &#123;<br>    time_value_t  user_time;      /* user run time */<br>    time_value_t  system_time;    /* system run time */<br>    integer_t    cpu_usage;       /* scaled cpu usage percentage */<br>    policy_t     policy;          /* scheduling policy in effect */<br>    integer_t    run_state;       /* run state (see below) */<br>    integer_t    flags;           /* various flags (see below) */<br>    integer_t    suspend_count;   /* suspend count for thread */<br>    integer_t    sleep_time;      /* number of seconds that thread  has been sleeping */<br>&#125;<br></code></pre></td></tr></table></figure><p>一个<code>Mach Task</code>包含它的线程列表。内核提供了<code>task_threads</code> API 调用获取指定 task 的线程列表，然后可以通过<code>thread_info</code> API调用来查询指定线程的信息，在 thread_act.h 中有相关定义。</p><p><code>task_threads</code> 将<code>target_task</code> 任务中的所有线程保存在<code>act_list</code>数组中，act_listCnt表示线程个数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">kern_return_t task_threads<br>(<br>    task_t target_task,<br>    thread_act_array_t *act_list,<br>    mach_msg_type_number_t *act_listCnt<br>);<br></code></pre></td></tr></table></figure><p> <code>thread_info</code>结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">kern_return_t</span> <span class="hljs-title">thread_info</span></span><br><span class="hljs-function"><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">thread_act_t</span> target_act,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">thread_flavor_t</span> flavor,  <span class="hljs-comment">// 传入不同的宏定义获取不同的线程信息</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">thread_info_t</span> thread_info_out,  <span class="hljs-comment">// 查询到的线程信息</span></span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">mach_msg_type_number_t</span> *thread_info_outCnt  <span class="hljs-comment">// 信息的大小</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><p> 如果频繁调用<code>task_threads</code>函数，来获取线程数量和增长速度，大量调用这个函数会造成一定的性能问题</p><p>通过<code>hook</code>线程的创建和销毁，来监听线程的数量</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//在#include &lt;pthread/introspection.h&gt;文件里</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">定义函数指针：pthread_introspection_hook_t</span><br><span class="hljs-comment">event  : 线程处于的生命周期（下面枚举了线程的4个生命周期）</span><br><span class="hljs-comment">thread ：线程</span><br><span class="hljs-comment">addr   ：线程栈内存基址</span><br><span class="hljs-comment">size   ：线程栈内存可用大小</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*<span class="hljs-type">pthread_introspection_hook_t</span>)</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> event,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">pthread_t</span> thread, <span class="hljs-type">void</span> *addr, <span class="hljs-type">size_t</span> size)</span></span>;<br><br><span class="hljs-keyword">enum</span> &#123;<br>PTHREAD_INTROSPECTION_THREAD_CREATE = <span class="hljs-number">1</span>, <span class="hljs-comment">//创建线程</span><br>PTHREAD_INTROSPECTION_THREAD_START, <span class="hljs-comment">// 线程开始运行</span><br>PTHREAD_INTROSPECTION_THREAD_TERMINATE,  <span class="hljs-comment">//线程运行终止</span><br>PTHREAD_INTROSPECTION_THREAD_DESTROY, <span class="hljs-comment">//销毁线程</span><br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">看这个函数名，很像我们平时hook函数一样的。</span><br><span class="hljs-comment">返回值是上面声明的pthread_introspection_hook_t函数指针：返回原线程生命周期函数。</span><br><span class="hljs-comment">参数也是函数指针：传入的是我们自定义的线程生命周期函数</span><br><span class="hljs-comment">*/</span><br>__attribute__((__nonnull__, __warn_unused_result__))<br><span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-type">pthread_introspection_hook_t</span></span><br><span class="hljs-function"><span class="hljs-title">pthread_introspection_hook_install</span><span class="hljs-params">(<span class="hljs-type">pthread_introspection_hook_t</span> hook)</span></span>;<br><br></code></pre></td></tr></table></figure><h4 id="下面开始写一个Monitor"><a href="#下面开始写一个Monitor" class="headerlink" title="下面开始写一个Monitor"></a>下面开始写一个<code>Monitor</code></h4><p>先来定义一些参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">static pthread_introspection_hook_t original_pthread_introspection_hook_t = NULL;<br><br>/// 创建信号量<br>static dispatch_semaphore_t semaphore;<br><br>/// 线程总数<br>static int threadCount = 0;<br><br>/// 是否开启监控<br>static bool isMonitor = false;<br><br>/// 线程总数阈值<br>static int averageThreadCount = 40;<br><br>/// 线程在一定时间内新增数<br>static int newThreadCount = 0;<br><br>/// 线程在一定时间内新增阈值<br>static int newAverageThreadCount = 10;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">/// 开启监控<br>+ (void)startMonitor&#123;<br>    // 创建信号量 最大并发数为1<br>    semaphore = dispatch_semaphore_create(1);<br>    // 等待<br>    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>    <br>    mach_msg_type_number_t count;<br>    thread_act_array_t threads;<br>    // 获取到count<br>    task_threads(mach_task_self(), &amp;threads, &amp;count);<br>   <br>    // 保证加锁的时候，线程数量不变<br>    threadCount = count;<br>    <br>    // 添加🪝钩子函数<br>    original_pthread_introspection_hook_t = pthread_introspection_hook_install(kry_pthread_introspection_hook_t);<br>    <br>    // 解锁 信号量+1<br>    dispatch_semaphore_signal(semaphore);<br>    <br>    // 开始监控<br>    isMonitor = true;<br>    <br>    <br>    // 开启一个定时器 检测每秒线程创建 然后通过clearNewThreadCount置位0<br>    const char *queenIdentifier = dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL);<br>    if (queenIdentifier == dispatch_queue_get_label(dispatch_get_main_queue())) &#123;<br>        [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(clearNewThreadCount) userInfo:nil repeats:YES];<br>    &#125;else&#123;<br>        dispatch_async(dispatch_get_main_queue(), ^&#123;<br>        [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(clearNewThreadCount) userInfo:nil repeats:YES];<br>        &#125;);<br>    &#125;<br>&#125;<br><br>// 当前线程总数<br>+ (int)currentThreadCount&#123;<br>    return threadCount;<br>&#125;<br><br>void kry_pthread_introspection_hook_t(unsigned int event,<br>                                      pthread_t thread, void *addr, size_t size)&#123;<br>    <br>    // 正常调用原有逻辑<br>    if (original_pthread_introspection_hook_t) &#123;<br>        original_pthread_introspection_hook_t(event,thread,addr,size);<br>    &#125;<br>    <br>    // 开始记录<br>    <br>    // 如果是创建线程,则线程的数量+1，新增数+1<br>    if (event == PTHREAD_INTROSPECTION_THREAD_CREATE) &#123;<br>        threadCount +=1;<br>        if (isMonitor &amp;&amp; threadCount &gt; averageThreadCount) &#123;<br>            // 总数 超过阈值 警告或者记录堆栈<br>            kry_Log_CallStack(false, 0);<br>        &#125;<br>        <br>        newThreadCount +=1;<br>        if (isMonitor &amp;&amp; newThreadCount &gt; newAverageThreadCount) &#123;<br>            // 新增数 超过阈值 警告或者记录堆栈<br>            kry_Log_CallStack(true, newThreadCount);<br>        &#125;<br>    &#125;<br>    <br>    <br>    // 销毁线程，则线程数量-1，新增数-1<br>    if (event == PTHREAD_INTROSPECTION_THREAD_DESTROY) &#123;<br>        threadCount -=1;<br>       <br>        if (newThreadCount &gt; 0 ) &#123;<br>            newThreadCount -=1;<br>        &#125;<br>        <br>    &#125;<br>&#125;<br><br><br>void kry_Log_CallStack(bool isIncreaseLog, int num)<br>&#123;<br>    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>    if (isIncreaseLog) &#123;<br>        printf(&quot;\n🔥一秒钟开启 %d 条线程！！！！\n&quot;, num);<br>    &#125;<br>    // 可以记录堆栈信息<br>    dispatch_semaphore_signal(semaphore);<br>&#125;<br><br>+ (void)clearNewThreadCount&#123;<br>    newThreadCount = 0;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码很简单，都有注释，近期在看PCL的堆栈记录，后期会把堆栈记录完善上去</p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="https://www.jianshu.com/p/95df83780c8f">APP性能检测方案汇总</a></p><p><a href="https://juejin.cn/post/6844904122248855560">iOS线程数量监控工具</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-自定义Section延迟load加载</title>
    <link href="/2021/07/01/iOS-%E8%87%AA%E5%AE%9A%E4%B9%89Section%E5%BB%B6%E8%BF%9Fload%E5%8A%A0%E8%BD%BD/"/>
    <url>/2021/07/01/iOS-%E8%87%AA%E5%AE%9A%E4%B9%89Section%E5%BB%B6%E8%BF%9Fload%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h4 id="在指定的segment和section中存入数据"><a href="#在指定的segment和section中存入数据" class="headerlink" title="在指定的segment和section中存入数据"></a>在指定的segment和section中存入数据</h4><p>之前我们已经了解过<code>machO</code>的结构了，那么我们有没有办法去修改或者新增<code>segment</code>和<code>section</code>当中的数据呢，答案是可以的，使用<code>__attribute__ section</code>将指定的数据存储到指定的<code>segmemt</code>和<code>section</code>中，也可以在通过在<code>Build Settings</code>中的<code>Other Linker Flags</code>设置链接参数，从而达到移动段，新增段，赋予权限等操作</p><h4 id="attribute-的用法"><a href="#attribute-的用法" class="headerlink" title=" __attribute__的用法"></a><code> __attribute__</code>的用法</h4><p><code>__attribute__</code> 可以用来设置函数属性（Function Attribute）、变量属性（Variable Attribute）和类型属性（Type Attribute）</p><ul><li><code>__attribute__((format()))</code> 按照指定格式进行参数检查。</li></ul><hr><ul><li><code>__attribute__((__always_inline__))</code> 强制内联。</li></ul><hr><ul><li><code>__attribute__((deprecated(&quot;Use xxx: instead&quot;)</code> 这个可能是我们见的比较多的，用来标记某个方法已经被废弃了，需要用其它的方法代替。</li></ul><hr><ul><li><code>__attribute__((__unused__))</code> 标记函数或变量可能不会用到。</li></ul><hr><ul><li><p><code>__attribute__((visibility(&quot;visibility_type&quot;)))</code> 标记动态库符号是否可见，有以下取值：</p><pre><code class="hljs">   1.  `default` 符号可见，可导出。          2.  `hidden` 符号隐藏，不可导出，只能在本动态库内调用。</code></pre></li></ul><hr><ul><li><code>__attribute__((objc_designated_initializer))</code> 明确指定用于初始化的方法。一个优秀的设计，初始化接口可以有多个，但最终多个初始化初始化接口都会调用 <code>designed initializer</code> 方法。</li></ul><hr><ul><li><code>__attribute__((unavailable))</code>、<code>__attribute__((unavailable(&quot;Must use xxx: instead.&quot;)));</code> 标记方法被禁用，不能直接调用，但这并不意味着该方法不能被调用，在 Objective-C 中使用 runtime 依然可以调用。</li></ul><hr><ul><li><code>__attribute__((section(&quot;segment,section&quot;)))</code> 将一个指定的数据储存到我们需要的 segment 和 section 中。</li></ul><hr><ul><li><code>__attribute__((constructor))</code> 被 <code>attribute((constructor))</code> 标记的函数，会在 <code>main</code> 函数之前或动态库加载时执行。在 mach-o 中，被 <code>attribute((constructor))</code> 标记的函数会在 <code>_DATA</code> 段的 <code>__mod_init_func</code> 区中。当多个被标记 <code>attribute((constructor))</code> 的方法想要有顺序的执行，怎么办？<code>attribute((constructor))</code> 是支持优先级的：<code>_attribute((constructor(1)))</code></li></ul><hr><ul><li><code>__attribute__((destructor))</code> 和 <code>attribute((constructor))</code> 相反：被 <code>attribute((destructor))</code> 标记的函数，会在 <code>main</code> 函数退出或动态库卸载时执行。在 mach-o 中此类函数会放在 <code>_DATA</code> 段的 <code>__mod_term_func</code> 区中</li></ul><p>… 还有很多 这里就不一一列举了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">JYProtocolInfo</span>&#123;<br>    <span class="hljs-type">char</span> *className;<br>    <span class="hljs-type">char</span> *method;<br>&#125;;<br><br> <br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> JYProtocolRegister(_className_,_method_)\</span><br><span class="hljs-meta">__attribute__((used)) static struct JYProtocolInfo JYProtocolInfo##_className_ \</span><br><span class="hljs-meta">__attribute__ ((used, section (<span class="hljs-string">&quot;__DATA,JYLoadDelayData&quot;</span>))) =\</span><br><span class="hljs-meta">&#123;\</span><br><span class="hljs-meta">    .className = #_className_,\</span><br><span class="hljs-meta">    .method = #_method_,\</span><br><span class="hljs-meta">&#125;;</span><br><br><br>@interface JYLoadDelayTool : NSObject<br><br>+ (<span class="hljs-type">void</span>)readDataFromMachO;<br><br>+ (<span class="hljs-type">void</span>)xxx;<br><br>@end<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">JYProtocolRegister</span>(JYLoadDelayTool,xxx)<br><br>+ (<span class="hljs-type">void</span>)xxx&#123;<br>    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;123&quot;</span>);<br>&#125;<br><br>+ (<span class="hljs-type">void</span>)readDataFromMachO &#123;<br>   <br>     Dl_info info;<br>     <span class="hljs-built_in">dladdr</span>((__bridge <span class="hljs-type">void</span> *)[self <span class="hljs-keyword">class</span>], &amp;info);<br><br>    <span class="hljs-comment">// 读取__DATA中自定义的ProtocolInfoDataz数据</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __LP64__</span><br>        <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mach_header</span> *mhp = (<span class="hljs-keyword">struct</span> mach_header*)info.dli_fbase;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> schemeSize = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">uint32_t</span> *schemeMemory = (<span class="hljs-type">uint32_t</span>*)<span class="hljs-built_in">getsectiondata</span>(mhp, <span class="hljs-string">&quot;__DATA&quot;</span>, <span class="hljs-string">&quot;JYLoadDelayData&quot;</span>, &amp;schemeSize);<br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span> <span class="hljs-comment">/* defined(__LP64__) */</span></span><br>        <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">mach_header_64</span> *mhp = (<span class="hljs-keyword">struct</span> mach_header_64*)info.dli_fbase;<br>        <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> schemeSize = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">uint64_t</span> *schemeMemory = (<span class="hljs-type">uint64_t</span>*)<span class="hljs-built_in">getsectiondata</span>(mhp, <span class="hljs-string">&quot;__DATA&quot;</span>, <span class="hljs-string">&quot;JYLoadDelayData&quot;</span>, &amp;schemeSize);<br><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* defined(__LP64__) */</span></span><br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> schemeCounter = schemeSize/<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> JYProtocolInfo);<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">JYProtocolInfo</span> *items = (<span class="hljs-keyword">struct</span> JYProtocolInfo*)schemeMemory;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>; idx &lt; schemeCounter; ++idx)&#123;<br>        <br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">JYProtocolInfo</span> * info = (<span class="hljs-keyword">struct</span> JYProtocolInfo*)&amp;items[idx];<br>        <br>        Class JYClass = <span class="hljs-built_in">NSClassFromString</span>([NSString stringWithUTF8String:info-&gt;className]);<br><br>        SEL sel = <span class="hljs-built_in">NSSelectorFromString</span>([NSString stringWithUTF8String:info-&gt;method]);<br>        <br>        <span class="hljs-built_in">id</span> (*func)(Class, SEL) = (<span class="hljs-built_in">id</span> (*)(Class, SEL))objc_msgSend;<br>       <br>        <span class="hljs-built_in">func</span>(JYClass, sel);<br>    &#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure><p>这样，可以把一些<code>+load</code>的方法都通过指定<code>JYProtocolRegister</code>来加载，这样可以优化启动时间，另外我们APM的监控，应该是最早的，这样在APP启动后的问题都能够检测到，如果<code>load</code>里面的方法有性能问题，而APM监控却是在<code>load</code>之后，那么就会检查不到，所以一些非必要性的<code>load</code>方法可以放在APM之后加载，通过上述方式</p><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><p><a href="https://juejin.cn/post/6980545001126101005">iOS APP 启动优化(六)：在指定的 segment 和 section 中存入数据</a></p><p><a href="https://xiaozhuanlan.com/topic/9204153876">iOS开发之runtime（12）：深入 Mach-O</a></p>]]></content>
    
    
    <categories>
      
      <category>iOS进阶</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-系统内存泄露</title>
    <link href="/2021/07/01/iOS-%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    <url>/2021/07/01/iOS-%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/</url>
    
    <content type="html"><![CDATA[<p>下面是复现泄漏的测试代码，<code>JYObject</code>是一个没有任何多余代码的类，继承自<code>NSObject</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">JYObject * jyobject = [JYObject <span class="hljs-keyword">new</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span> * <span class="hljs-number">1000</span>; ++i) &#123;<br>    id value = @<span class="hljs-string">&quot;JY&quot;</span>;<br>    [jyobject validateValue:&amp;value forKey:@<span class="hljs-string">&quot;notexistkey&quot;</span> error:nil];<br>&#125;<br></code></pre></td></tr></table></figure><p>当对一个没有实现校验方法的key进行<code>validateValue</code>时，就会有少量内存泄漏。如果执行很多次，结果还是很可观的。上面的代码会让内存飙到160M。</p><h4 id="定位泄漏源"><a href="#定位泄漏源" class="headerlink" title="定位泄漏源"></a>定位泄漏源</h4><p>这个泄漏使用Instruments的Leaks模版可以很快的发现，但是代码却不好定位。下面是Leaks报告的泄漏截图。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1h1nksnswpjj20yg06hwf7.jpg"></p><p>可以看出，泄漏发生在<code>validateValue:forKey:error:</code>，再细看右边的调用栈，可以看到这块内存是由<code>malloc</code>分配的。所以很有可能是这个系统方法内部发生了泄漏。</p><p>可以看出，泄漏发生在<code>validateValue:forKey:error:</code>，再细看右边的调用栈，可以看到这块内存是由<code>malloc</code>分配的。所以很有可能是这个系统方法内部发生了泄漏。</p><h4 id="使用符号断点深入观察系统方法"><a href="#使用符号断点深入观察系统方法" class="headerlink" title="使用符号断点深入观察系统方法"></a>使用符号断点深入观察系统方法</h4><p>首先使用符号断点，让程序在<code>validateValue:forKey:error:</code>处停下。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/4/17/162d197750bcc39e~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><p>运行程序，命中断点后，我们就可以观察<code>validateValue:forKey:error:</code>的汇编代码了。</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/4/17/162d197750e0badd~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp" alt="img"></p><h4 id="寻找Leak的内存来源"><a href="#寻找Leak的内存来源" class="headerlink" title="寻找Leak的内存来源"></a>寻找Leak的内存来源</h4><p>在汇编代码中，我发现了一个malloc调用和一个free调用。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">0x1048272ef</span> &lt;+<span class="hljs-number">63</span>&gt;:  callq  <span class="hljs-number">0x10498b1da</span>               <span class="hljs-comment">; symbol stub for: malloc</span><br>...<br><span class="hljs-number">0x104827389</span> &lt;+<span class="hljs-number">217</span>&gt;: callq  <span class="hljs-number">0x10498b066</span>               <span class="hljs-comment">; symbol stub for: free</span><br>复制代码<br></code></pre></td></tr></table></figure><p>通过单步调试发现，malloc出来的内存主要用来存储key，并且把首字母变成大写，应该是为了方便构成<code>validate&lt;Key&gt;:error:</code>的selector name。不过如果对象上没有校验这个key的方法，那么代码会直接jump到free调用的下二行。这样这个内存块就永远不会被释放了。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0x104827390</span> &lt;+<span class="hljs-number">224</span>&gt;: movb   $<span class="hljs-number">0</span>x1, %r14b<br></code></pre></td></tr></table></figure><p>当我们给LeakObject加上notexistkey的校验方法后，单步可以发现free被调用。下面是增加的校验方法。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">- (BOOL)validateNotexistkey:(<span class="hljs-built_in">id</span> *)value <span class="hljs-keyword">error</span>:(NSError **)<span class="hljs-keyword">error</span> &#123;<br><span class="hljs-built_in">    return</span> YES;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>这次泄漏的寻找过程，大致可以分为</p><ol><li>使用Instruments Leak模版初步定位</li><li>使用符号断点深入泄漏方法，如果泄漏的方法不是系统或者第三方静态（动态）库的方法，就不用这么麻烦了。</li><li>关注泄漏内存块的分配释放方式，在源码或者汇编代码中寻找匹配的内存块。 由于这次泄漏的仅仅是malloc内存块，所以OC的引用计数记录并不能起什么作用。</li></ol>]]></content>
    
    
    <categories>
      
      <category>iOS日常问题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-逆向防护</title>
    <link href="/2021/06/01/iOS-%E9%80%86%E5%90%91%E9%98%B2%E6%8A%A4/"/>
    <url>/2021/06/01/iOS-%E9%80%86%E5%90%91%E9%98%B2%E6%8A%A4/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="MethodSwizzle"><a href="#MethodSwizzle" class="headerlink" title="**MethodSwizzle **"></a>**MethodSwizzle **</h3><ul><li>利用OC的运行时（Runtime）特性修改 <code>SEL</code> 和 <code>IMP(函数指针)</code> 的关系，打到Hook OC方法的目的</li><li><code>method_exchangeIMP</code>交换两个 <code>IMP</code></li><li><code>class_replaceMethod</code>替换某个 <code>SEL</code>的 <code>IMP</code> （如果没有该方法就添加，相当于换掉这个方法）</li><li><code>method_getImplementation</code> 、<code>method_setImplementation</code> 获取和设置某个方法的IMP （很多第三方框架都使用）</li></ul><hr><h3 id="MonKey-Hook"><a href="#MonKey-Hook" class="headerlink" title="MonKey Hook"></a>MonKey Hook</h3><p>Monkey中使用了  <code>libsubstrate.dylib</code></p><ul><li><code>method_setImplementation</code></li><li><code>method_getImplementation</code></li></ul><h4 id="MonKey已经替换的系统函数"><a href="#MonKey已经替换的系统函数" class="headerlink" title="MonKey已经替换的系统函数"></a><strong>MonKey已经替换的系统函数</strong></h4><ul><li>dlsym </li><li>sysctl</li><li>ptrace</li></ul><hr><h3 id="Dobby-（修改静态函数-C-和-swift）"><a href="#Dobby-（修改静态函数-C-和-swift）" class="headerlink" title="Dobby （修改静态函数 C 和 swift）"></a>Dobby （修改静态函数 C 和 swift）</h3><ul><li>实际上是替换 <code>Text段</code>   </li><li>动态修改 （加载到内存的时候修改）</li></ul><hr><h3 id="防护-：lldb-ptrace"><a href="#防护-：lldb-ptrace" class="headerlink" title="防护 ：lldb - ptrace"></a>防护 ：<code>lldb - ptrace</code></h3><ul><li><code>ptrace</code> 是 命令行工程以及 Mac OS 工程里的 <code>&lt;sys/ptrace.h&gt;</code>提供的一个函数 , 可以用来来控制进程附加管理 , 它可以实现禁止应用程序进程被附加的效果 . 在 iOS 中并没有暴露出来 , 但是 iOS 是可以使用的 .</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> arg1: ptrace要做的事情: PT_DENY_ATTACH 表示要控制的是当前进程不允许被附加</span><br><span class="hljs-comment"> arg2: 要操作进程的PID , 0就代表自己</span><br><span class="hljs-comment"> arg3: 地址 取决于第一个参数要做的处理不同传递不同</span><br><span class="hljs-comment"> arg4: 数据 取决于第一个参数要做的处理不同传递不同</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">ptrace</span>(PT_DENY_ATTACH, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><ul><li><p>效果：</p><ul><li>运行工程 , 程序闪退 .</li><li>从手机点开应用 , 应用正常 .</li><li>使用Xcode 自带的 Debug - Attach to process 发现附加失败</li></ul></li><li><p>破解：</p><ul><li>通过符号断点检测</li><li>使用 <code>fishhook</code>  HOOK掉ptrace这个函数</li></ul></li></ul><hr><h3 id="防护：-sysctl"><a href="#防护：-sysctl" class="headerlink" title="防护： sysctl"></a>防护： sysctl</h3><ul><li><code>sysctl ( system control )</code> 是由 <code>&lt;sys/sysctl.h&gt;</code> 提供的一个函数 , 它有很多作用 , 其中一个是可以监测当前进程有没有被附加 . 但是因为其特性 , 只是监测当前时刻应用有没有被附加 .</li><li>因此正向开发中我们往往结合定时器一起使用 , 或者 定时 &#x2F; 定期 &#x2F; 在特定时期 去使用 .</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#import <span class="hljs-string">&quot;ViewController.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;sys/sysctl.h&gt;</span></span><br>@<span class="hljs-function">interface <span class="hljs-title">ViewController</span> <span class="hljs-params">()</span></span><br><span class="hljs-function">@end</span><br><span class="hljs-function"></span><br><span class="hljs-function">@implementation ViewController</span><br><span class="hljs-function">BOOL <span class="hljs-title">isDebug</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> name[<span class="hljs-number">4</span>];             <span class="hljs-comment">//里面放字节码。查询的信息</span><br>    name[<span class="hljs-number">0</span>] = CTL_KERN;      <span class="hljs-comment">//内核查询</span><br>    name[<span class="hljs-number">1</span>] = KERN_PROC;     <span class="hljs-comment">//查询进程</span><br>    name[<span class="hljs-number">2</span>] = KERN_PROC_PID; <span class="hljs-comment">//传递的参数是进程的ID</span><br>    name[<span class="hljs-number">3</span>] = <span class="hljs-built_in">getpid</span>();      <span class="hljs-comment">//获取当前进程ID</span><br>    <br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">kinfo_proc</span> info;  <span class="hljs-comment">//接受查询结果的结构体</span><br>    <span class="hljs-type">size_t</span> info_size = <span class="hljs-built_in">sizeof</span>(info);  <span class="hljs-comment">//结构体大小</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">sysctl</span>(name, <span class="hljs-number">4</span>, &amp;info, &amp;info_size, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))&#123;<br>        <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;查询失败&quot;</span>);<br>        <span class="hljs-keyword">return</span> NO;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    查询结果看info.kp_proc.p_flag 的第12位。如果为1，表示调试状态。</span><br><span class="hljs-comment">    (info.kp_proc.p_flag &amp; P_TRACED) 就是0x800, 即可获取第12位</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> ((info.kp_proc.p_flag &amp; P_TRACED) != <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">dispatch_source_t</span> timer;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">debugCheck</span><span class="hljs-params">()</span></span>&#123;<br>    timer = <span class="hljs-built_in">dispatch_source_create</span>(DISPATCH_SOURCE_TYPE_TIMER, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">dispatch_get_global_queue</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>    <span class="hljs-built_in">dispatch_source_set_timer</span>(timer, DISPATCH_TIME_NOW, <span class="hljs-number">1.0</span> * NSEC_PER_SEC, <span class="hljs-number">0.0</span> * NSEC_PER_SEC);<br>    <span class="hljs-built_in">dispatch_source_set_event_handler</span>(timer, ^&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isDebug</span>()) &#123;<span class="hljs-comment">//在这里写你检测到调试要做的操作</span><br>            <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;调试状态!&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;正常！&quot;</span>);<br>        &#125;<br>    &#125;);<br>    <span class="hljs-built_in">dispatch_resume</span>(timer);<br>&#125;<br><br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [super viewDidLoad];<br>    <span class="hljs-built_in">debugCheck</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>效果：</p><ul><li>可以上报或者 <code>exit</code></li></ul></li><li><p>破解：</p><ul><li>因为 <code>sysctl</code>函数也是系统函数，从而可以使用fishHook来交换</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">int</span>  (*sysctl_ptr)(<span class="hljs-type">int</span> *, u_int, <span class="hljs-type">void</span> *, <span class="hljs-type">size_t</span> *, <span class="hljs-type">void</span> *, <span class="hljs-type">size_t</span>);<br><br><span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">my_sysctl</span><span class="hljs-params">(<span class="hljs-type">int</span> * name, u_int namelen, <span class="hljs-type">void</span> * info, <span class="hljs-type">size_t</span> * infoSize, <span class="hljs-type">void</span> * newInfo, <span class="hljs-type">size_t</span> newInfoSize)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (name[<span class="hljs-number">0</span>] == CTL_KERN &amp;&amp; name[<span class="hljs-number">1</span>] == KERN_PROC &amp;&amp; name[<span class="hljs-number">2</span>] == KERN_PROC_PID &amp;&amp; *infoSize == <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> kinfo_proc)) &#123;<br>        <br>        <span class="hljs-type">int</span> old = <span class="hljs-built_in">sysctl_ptr</span>(name,namelen,info,infoSize,newInfo,newInfoSize);<br>        <span class="hljs-comment">//拿出info</span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">kinfo_proc</span> * myinfo = (<span class="hljs-keyword">struct</span> kinfo_proc *)info;<br>        <br>        <span class="hljs-keyword">if</span> ((myinfo-&gt;kp_proc.p_flag &amp; P_TRACED ) != <span class="hljs-number">0</span> ) &#123;<br>            <span class="hljs-comment">//使用异或取反</span><br>            myinfo-&gt;kp_proc.p_flag ^= P_TRACED;<br>        &#125;<br>        <span class="hljs-keyword">return</span> old;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sysctl_ptr</span>(name,namelen,info,infoSize,newInfo,newInfoSize);<br>&#125;<br><br>+(<span class="hljs-type">void</span>)load&#123;<br>  <br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rebinding</span> rebingSysctl;<br>    rebingSysctl.name = <span class="hljs-string">&quot;sysctl&quot;</span>;<br>    rebingSysctl.replacement = my_sysctl;<br>    rebingSysctl.replaced = (<span class="hljs-type">void</span> *)&amp;sysctl_ptr;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rebinding</span> rebs[<span class="hljs-number">1</span>] = &#123;rebingSysctl&#125;;<br>    <span class="hljs-built_in">rebind_symbols</span>(rebs, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>注意：<ul><li>需要慎用 <code>exit</code> 函数</li><li>逆向中通过 <code>exit</code>  添加符号断点，就可以查看函数调用栈，从而可以看到调用 <code>exit</code>的函数地址，在减去首地址就可以拿到函数的偏移量，接着在 <code>Hopper</code> 当中就可以知道调用 <code>exit</code> 的地址了</li><li>我们自己开发所使用的 <code> framework</code> 会比注入的动态库更早的执行，虽然还是会被 <code>fishhook</code> 替换掉，但是可以在此之前，禁用掉 <code>fishhook</code> 或者完成检测</li><li>只不过如果破解人员找到这个 <code>framework</code> ，然后在 <code>load</code> 方法中直接 <code>Return</code></li></ul></li></ul><hr><hr><h3 id="防护：-通过函数地址直接调用-ptrace-和-sysctl"><a href="#防护：-通过函数地址直接调用-ptrace-和-sysctl" class="headerlink" title="防护： 通过函数地址直接调用 ptrace 和 sysctl"></a>防护： 通过函数地址直接调用 <code>ptrace</code> 和 <code>sysctl</code></h3><ul><li><p>在我工程开始我就获取 <code>ptrace / sysctl</code> 的地址 , 后面直接使用地址调用这个函数 . 实际上是可行的 , 利用 <code>dlsym</code>这个函数 .</p><ul><li>通过符号获取函数地址 ( dladdr 函数 ) </li><li>通过函数内部地址找到函数符号 ( dlsym 函数 )</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#import <span class="hljs-string">&quot;MyPtraceHeader.h&quot;</span></span><br><span class="hljs-meta">#import <span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br>  <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">callFunAddres</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">int</span> name[<span class="hljs-number">4</span>];             <span class="hljs-comment">//里面放字节码。查询的信息</span><br>    name[<span class="hljs-number">0</span>] = CTL_KERN;      <span class="hljs-comment">//内核查询</span><br>    name[<span class="hljs-number">1</span>] = KERN_PROC;     <span class="hljs-comment">//查询进程</span><br>    name[<span class="hljs-number">2</span>] = KERN_PROC_PID; <span class="hljs-comment">//传递的参数是进程的ID</span><br>    name[<span class="hljs-number">3</span>] = <span class="hljs-built_in">getpid</span>();      <span class="hljs-comment">//获取当前进程ID</span><br>    <br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">kinfo_proc</span> info;  <span class="hljs-comment">//接受查询结果的结构体</span><br>    <span class="hljs-type">size_t</span> info_size = <span class="hljs-built_in">sizeof</span>(info);  <span class="hljs-comment">//结构体大小</span><br>    <br>    <span class="hljs-comment">//这里做法是隐藏常量字符串</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str[] = &#123;<br>        (<span class="hljs-string">&#x27;a&#x27;</span> ^ <span class="hljs-string">&#x27;s&#x27;</span>),<br>        (<span class="hljs-string">&#x27;a&#x27;</span> ^ <span class="hljs-string">&#x27;y&#x27;</span>),<br>        (<span class="hljs-string">&#x27;a&#x27;</span> ^ <span class="hljs-string">&#x27;s&#x27;</span>),<br>        (<span class="hljs-string">&#x27;a&#x27;</span> ^ <span class="hljs-string">&#x27;c&#x27;</span>),<br>        (<span class="hljs-string">&#x27;a&#x27;</span> ^ <span class="hljs-string">&#x27;t&#x27;</span>),<br>        (<span class="hljs-string">&#x27;a&#x27;</span> ^ <span class="hljs-string">&#x27;l&#x27;</span>),<br>        (<span class="hljs-string">&#x27;a&#x27;</span> ^ <span class="hljs-string">&#x27;\0&#x27;</span>)<br>    &#125;;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> * p = str;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);<br>    <span class="hljs-keyword">while</span> (((*p) ^= <span class="hljs-string">&#x27;a&#x27;</span>) != <span class="hljs-string">&#x27;\0&#x27;</span>) p++;<br>    <br>    <span class="hljs-type">void</span> * handle = <span class="hljs-built_in">dlopen</span>(<span class="hljs-string">&quot;/usr/lib/system/libsystem_c.dylib&quot;</span>, RTLD_LAZY);<br><br>    <span class="hljs-built_in">int</span>  (*sysctl_ptr)(<span class="hljs-type">int</span> *, u_int, <span class="hljs-type">void</span> *, <span class="hljs-type">size_t</span> *, <span class="hljs-type">void</span> *, <span class="hljs-type">size_t</span>);<br>    <span class="hljs-comment">//获取sysctl函数指针</span><br>    sysctl_ptr = <span class="hljs-built_in">dlsym</span>(handle,(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)str);<br>    <span class="hljs-keyword">if</span> (sysctl_ptr) &#123;<br>        <br>        <span class="hljs-built_in">sysctl_ptr</span>(name, <span class="hljs-number">4</span>, &amp;info, &amp;info_size, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>      <br>        <span class="hljs-keyword">if</span> ((info.kp_proc.p_flag &amp; P_TRACED ) != <span class="hljs-number">0</span> )&#123;<br>            <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;调试状态&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;正常&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>破解 <ul><li>使用 <code>fishhook </code> 将  <code>dlopen</code> 与 <code>dlsym</code> 这两个系统函数干掉</li></ul></li></ul><hr><hr><h3 id="防护-汇编"><a href="#防护-汇编" class="headerlink" title="防护 汇编"></a>防护 汇编</h3><ul><li>使用汇编直接调用</li></ul><hr><hr><h3 id="字符串常量隐藏"><a href="#字符串常量隐藏" class="headerlink" title="字符串常量隐藏"></a>字符串常量隐藏</h3><ul><li>例如在App内注册第三方APP的Key,SecretKey等，字符串常量隐藏</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> kWxAppID @<span class="hljs-string">&quot;krystal69d7xxxxxx&quot;</span>  </span><br> - (<span class="hljs-type">void</span>)configureForWXSDK&#123;<br>    [WXApi registerApp:kWxAppID<br>         universalLink:@<span class="hljs-string">&quot;123123&quot;</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>利用Hopper打开MachO就可以看到<br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gslif4da10j31lw0egmze.jpg">  </p><ul><li>解决办法<ul><li>在方法中返回这个字符串</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> KRYSTAL_ENCRYPT_KEY @<span class="hljs-string">&quot;krystal_key&quot;</span></span><br>@implementation ViewController<br>- (<span class="hljs-type">void</span>)viewDidLoad &#123;<br>    [super viewDidLoad];<br>    <span class="hljs-comment">//使用函数代替字符串</span><br>    [self uploadDataWithKey:<span class="hljs-built_in">AES_KEY</span>()];  <br>&#125;<br><br>- (<span class="hljs-type">void</span>)uploadDataWithKey:(NSString *)key&#123;<br>    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;%@&quot;</span>,key);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> NSString * <span class="hljs-title">AES_KEY</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> key[] = &#123;<br>        <span class="hljs-string">&#x27;k&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-string">&#x27;s&#x27;</span>,<span class="hljs-string">&#x27;t&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;l&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>,<span class="hljs-string">&#x27;k&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>,<span class="hljs-string">&#x27;y&#x27;</span>,<span class="hljs-string">&#x27;\0&#x27;</span>,<br>    &#125;;<br>    <span class="hljs-keyword">return</span> [NSString stringWithUTF8String:(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)key];<br>&#125;<br>@end<br></code></pre></td></tr></table></figure><ul><li><p><strong>破解：</strong></p><ul><li>静态分析需要找到这个返回 <code> Key</code> 函数</li></ul></li><li><p><strong>升级防护</strong></p><ul><li>通过异或方式</li><li>这些字符不会进入字符常量区 . 编译器直接换算成异或结果 .<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> STRING_ENCRYPT_KEY @<span class="hljs-string">&quot;demo_AES_key&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENCRYPT_KEY 0xAC</span><br>@<span class="hljs-function">interface <span class="hljs-title">ViewController</span> <span class="hljs-params">()</span></span><br><span class="hljs-function">@end</span><br><span class="hljs-function"></span><br><span class="hljs-function">@implementation ViewController</span><br><span class="hljs-function">- <span class="hljs-params">(<span class="hljs-type">void</span>)</span>viewDidLoad </span>&#123;<br>    [super viewDidLoad];<br><span class="hljs-comment">//    [self uploadDataWithKey:STRING_ENCRYPT_KEY]; //使用宏/常量字符串</span><br>    [self uploadDataWithKey:<span class="hljs-built_in">AES_KEY</span>()]; <span class="hljs-comment">//使用函数代替字符串</span><br>&#125;<br><br>- (<span class="hljs-type">void</span>)uploadDataWithKey:(NSString *)key&#123;<br>    <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;%@&quot;</span>,key);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> NSString * <span class="hljs-title">AES_KEY</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> key[] = &#123;<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;d&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;e&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;m&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;o&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;_&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;A&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;E&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;S&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;_&#x27;</span>),<br>        (ENCRYPT_KEY ^ <span class="hljs-string">&#x27;\0&#x27;</span>),<br>    &#125;;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> * p = key;<br>    <span class="hljs-keyword">while</span> (((*p) ^= ENCRYPT_KEY) != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<br>        p++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> [NSString stringWithUTF8String:(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)key];<br>&#125;<br>@end<br></code></pre></td></tr></table></figure></li></ul><ul><li><strong>效果：</strong><br><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gsm44y5b44j30o80ka76l.jpg"></li></ul></li></ul><hr><hr><hr><h3 id="动态库检测"><a href="#动态库检测" class="headerlink" title="动态库检测"></a>动态库检测</h3><ul><li><p>可以在服务器上存储一份 <code> _dyld_image_name</code></p></li><li><p>然后本地运行后获取到的上传服务器做比对</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++">+ (BOOL)isExternalLibs&#123;<br>    <span class="hljs-keyword">if</span>(TARGET_IPHONE_SIMULATOR)<span class="hljs-keyword">return</span> NO;<br>    <span class="hljs-type">int</span> dyld_count = _dyld_image_count();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; dyld_count; i++) &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> * imageName = _dyld_get_image_name(i);<br>        NSString *res = [NSString stringWithUTF8String:imageName];<br>        <span class="hljs-keyword">if</span>([res hasPrefix:@<span class="hljs-string">&quot;/var/containers/Bundle/Application&quot;</span>])&#123;<br>            <span class="hljs-keyword">if</span>([res hasSuffix:@<span class="hljs-string">&quot;.dylib&quot;</span>])&#123;<br>                <span class="hljs-comment">//这边还需要过滤掉自己项目中本身有的动态库</span><br>                <span class="hljs-keyword">return</span> YES;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> NO;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>破解：</strong> </p><ul><li>可以hook NSString的hasPrefix方法绕过检测</li></ul></li></ul><hr><hr><h3 id="防护-NSFileManager"><a href="#防护-NSFileManager" class="headerlink" title="防护  NSFileManager"></a>防护  NSFileManager</h3><ul><li>使用NSFileManager通过检测一些越狱后的关键文件&#x2F;路径是否可以访问来判断是否越狱 常见的文件&#x2F;路径有<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"> <span class="hljs-type">static</span> <span class="hljs-type">char</span> *JailbrokenPathArr[] = &#123;<span class="hljs-string">&quot;/Applications/Cydia.app&quot;</span>,<br>                                     <span class="hljs-string">&quot;/usr/sbin/sshd&quot;</span>,<br>                                     <span class="hljs-string">&quot;/bin/bash&quot;</span>,<br>                                     <span class="hljs-string">&quot;/etc/apt&quot;</span>,<br>                                     <span class="hljs-string">&quot;/Library/MobileSubstrate&quot;</span>,<br>                                     <span class="hljs-string">&quot;/User/Applications/&quot;</span>&#125;; <br>      <br>      <br>+ (BOOL)isJailbroken1&#123;<br>    <span class="hljs-keyword">if</span>(TARGET_IPHONE_SIMULATOR)<span class="hljs-keyword">return</span> NO;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">sizeof</span>(JailbrokenPathArr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span> *);i++) &#123;<br>        <span class="hljs-keyword">if</span>([[NSFileManager defaultManager] fileExistsAtPath:[NSString stringWithUTF8String:JailbrokenPathArr[i]]])&#123;<br>            <span class="hljs-keyword">return</span> YES;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> NO;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>破解<ul><li>攻击者可以通过hook NSFileManager的fileExistsAtPath方法来绕过检测<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//绕过使用NSFileManager判断特定文件是否存在的越狱检测，此时直接返回NO势必会影响程序中对这个方法的正常使用，因此可以先打印一下path，然后判断如果path是用来判断是否越狱则返回NO，否则按照正常逻辑返回</span><br>%hook NSFileManager<br>- (BOOL)fileExistsAtPath:(NSString *)path&#123;<br>    <span class="hljs-keyword">if</span>(TARGET_IPHONE_SIMULATOR)<span class="hljs-keyword">return</span> NO;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">sizeof</span>(JailbrokenPathArr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span> *);i++) &#123;<br>        NSString *jPath = [NSString stringWithUTF8String:JailbrokenPathArr[i]];<br>        <span class="hljs-keyword">if</span>([path isEqualToString:jPath])&#123;<br>            <span class="hljs-keyword">return</span> NO;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> %orig;<br>&#125;<br>%end<br><br></code></pre></td></tr></table></figure></li></ul></li></ul><hr><hr><h3 id="防护-stat-函数"><a href="#防护-stat-函数" class="headerlink" title="防护 stat 函数"></a>防护 <code>stat</code> 函数</h3><ul><li><p>使用C语言函数stat判断文件是否存在(注:stat函数用于获取对应文件信息，返回0则为获取成功，-1为获取失败)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++">+ (BOOL)isJailbroken2&#123;<br>    <span class="hljs-keyword">if</span>(TARGET_IPHONE_SIMULATOR)<span class="hljs-keyword">return</span> NO;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">sizeof</span>(JailbrokenPathArr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span> *);i++) &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> stat_info;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == <span class="hljs-built_in">stat</span>(JailbrokenPathArr[i], &amp;stat_info)) &#123;<br>            <span class="hljs-keyword">return</span> YES;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> NO;<br>&#125;      <br></code></pre></td></tr></table></figure></li><li><p>破解：</p><ul><li>使用fishhook可hook C函数，fishhook通过在mac-o文件中查找并替换函数地址达到hook的目的<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-title">int</span> <span class="hljs-params">(*orig_stat)</span><span class="hljs-params">(<span class="hljs-type">char</span> *c, <span class="hljs-keyword">struct</span> stat *s)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hook_stat</span><span class="hljs-params">(<span class="hljs-type">char</span> *c, <span class="hljs-keyword">struct</span> stat *s)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">sizeof</span>(JailbrokenPathArr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span> *);i++) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == <span class="hljs-built_in">strcmp</span>(c, JailbrokenPathArr[i]))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">orig_stat</span>(c,s);<br>&#125;<br>+(<span class="hljs-type">void</span>)statHook&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">rebinding</span> stat_rebinding = &#123;<span class="hljs-string">&quot;stat&quot;</span>, hook_stat, (<span class="hljs-type">void</span> *)&amp;orig_stat&#125;;<br>    <span class="hljs-built_in">rebind_symbols</span>((<span class="hljs-keyword">struct</span> rebinding[<span class="hljs-number">1</span>])&#123;stat_rebinding&#125;, <span class="hljs-number">1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure> 在动态库加载的时候，调用statHook    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"> %ctor&#123;<br>    [StatHook statHook];<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>判断stat的来源是否来自于系统库，因为fishhook通过交换函数地址来实现hook，若hook了stat，则stat来源将指向攻击者注入的动态库中 因此我们可以完善上方的isJailbroken2判断规则，若stat来源非系统库，则直接返回已越狱      </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++">+ (BOOL)isJailbroken2&#123;<br>    <span class="hljs-keyword">if</span>(TARGET_IPHONE_SIMULATOR)<span class="hljs-keyword">return</span> NO;<br>    <span class="hljs-type">int</span> ret ;<br>    Dl_info dylib_info;<br>    <span class="hljs-built_in">int</span> (*func_stat)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *, <span class="hljs-keyword">struct</span> stat *) = stat;<br>    <span class="hljs-keyword">if</span> ((ret = <span class="hljs-built_in">dladdr</span>(func_stat, &amp;dylib_info))) &#123;<br>        NSString *fName = [NSString stringWithUTF8String:dylib_info.dli_fname];<br>        <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">&quot;fname--%@&quot;</span>,fName);<br>        <span class="hljs-keyword">if</span>(![fName isEqualToString:@<span class="hljs-string">&quot;/usr/lib/system/libsystem_kernel.dylib&quot;</span>])&#123;<br>            <span class="hljs-keyword">return</span> YES;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-built_in">sizeof</span>(JailbrokenPathArr) / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span> *);i++) &#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span> stat_info;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == <span class="hljs-built_in">stat</span>(JailbrokenPathArr[i], &amp;stat_info)) &#123;<br>            <span class="hljs-keyword">return</span> YES;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> NO;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><hr><hr><hr><h3 id="BundleID检测"><a href="#BundleID检测" class="headerlink" title="BundleID检测"></a>BundleID检测</h3><ul><li>进行BundleID检测可以有效防止多开</li><li>获取当前项目的BundleID有多种方法，此处不再赘述，绕过检测则是hook对应的方法，返回原有的BundleID</li><li>防止攻击者绕过检测，可以在自行link的framework中获取BundleID并进行检测，以在被hook前进行校验<br> BundleID并进行校验以避免常见的BundleID获取方法被hook<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//获取Boundle ID</span><br><span class="hljs-type">char</span>  * bundleName =  getenv(<span class="hljs-string">&quot;XPC_SERVICE_NAME&quot;</span>);<br>    NSLog(@<span class="hljs-string">&quot;%s&quot;</span>,bundleName);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS逆向</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-夜间模式框架</title>
    <link href="/2021/05/01/%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F%E6%A1%86%E6%9E%B6/"/>
    <url>/2021/05/01/%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>iOS夜间模式的适配，主要用到了<code>NSProxy</code>转发原理 ，其中JYDynamicColor继承于UIColor</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface JYDynamicColor : UIColor<br><br>@property (nonatomic, readonly) UIColor * lightColor;<br><br>@property (nonatomic, readonly) UIColor * darkColor;<br><br>+ (UIColor *)colorWithLightColor:(UIColor *)lightColor darkColor:(UIColor *)darkColor;<br><br>+ (UIColor *)colorWithDynamicProvider:(UIColor * (^)(JYTraitCollection *traitCollection))dynamicProvider;<br><br>@end<br></code></pre></td></tr></table></figure><p>  但是在.m文件中,我们实际将消息给了JYDynamicColorProxy处理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@implementation JYDynamicColor<br><br>+ (UIColor *)colorWithLightColor:(UIColor *)lightColor darkColor:(UIColor *)darkColor &#123;<br>  return [self colorWithDynamicProvider:^(JYTraitCollection *traitCollection)&#123;<br>    return traitCollection.userInterfaceStyle == JYInterfaceStyleDark ? darkColor : lightColor;<br>  &#125;];<br>&#125;<br><br>+ (UIColor *)colorWithDynamicProvider:(UIColor * _Nonnull (^)(JYTraitCollection * _Nonnull))dynamicProvider &#123;<br>    <br>    return (JYDynamicColor *)[[JYDynamicColorProxy alloc] initWithDynamicProvider:dynamicProvider];<br>&#125;<br><br>- (UIColor *)lightColor &#123;<br>  NSAssert(NO, @&quot;This should never be called&quot;);<br>  return nil;<br>&#125;<br><br>- (UIColor *)darkColor &#123;<br>  NSAssert(NO, @&quot;This should never be called&quot;);<br>   return nil;<br>&#125;<br><br>@end<br></code></pre></td></tr></table></figure><p>接着看到<code>JYDynamicColorProxy</code>是继承于<code>NSProxy</code>，将所有的事件都转发到了<code>resolvedColor</code>，而<code>resolvedColor</code>是根据当前模式返回 <code>lightColor</code> 或者 <code>darkColor</code>,这样就实现了，对外其实是一个<code>UIColor</code>，但是实际上是一个<code>JYDynamicColorProxy</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface JYDynamicColorProxy : NSProxy &lt;NSCopying&gt;<br><br>@property (nonatomic, readonly) UIColor * resolvedColor;<br><br>@property (nonatomic, strong) UIColor *(^dynamicProvider)(JYTraitCollection *);<br><br>@end<br><br><br>@implementation JYDynamicColorProxy<br><br>- (instancetype)initWithDynamicProvider:(UIColor * (^)(JYTraitCollection *traitCollection))dynamicProvider &#123;<br>  self.dynamicProvider = dynamicProvider;<br>  return self;<br>&#125;<br><br>// MARK: NSProxy - 转发消息 将消息全部转发到 resolvedColor<br>- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123;<br>  return [self.resolvedColor methodSignatureForSelector:sel];<br>&#125;<br><br>- (void)forwardInvocation:(NSInvocation *)invocation &#123;<br>  [invocation invokeWithTarget:self.resolvedColor];<br>&#125;<br><br>- (UIColor *)resolvedColor &#123;<br>  return [self resolvedColorWithTraitCollection:JYTraitCollection.overrideTraitCollection];<br>&#125;<br><br>- (UIColor *)resolvedColorWithTraitCollection:(JYTraitCollection *)traitCollection &#123;<br>    return self.dynamicProvider(traitCollection);<br>&#125;<br><br>// MARK: UIColor<br>- (UIColor *)colorWithAlphaComponent:(CGFloat)alpha &#123;<br>  return [JYDynamicColor colorWithDynamicProvider:^UIColor *(JYTraitCollection *traitCollection) &#123;<br>    return [self.dynamicProvider(traitCollection) colorWithAlphaComponent:alpha];<br>  &#125;];<br>&#125;<br><br>- (CGColorRef)CGColor &#123;<br>  return [[self resolvedColor] CGColor];<br>&#125;<br><br><br>// MARK: NSObject<br>- (BOOL)isKindOfClass:(Class)aClass &#123;<br>  static JYDynamicColor *dynamicColor = nil;<br>  static dispatch_once_t onceToken;<br>  dispatch_once(&amp;onceToken, ^&#123;<br>    dynamicColor = [[JYDynamicColor alloc] init];<br>  &#125;);<br>  return [dynamicColor isKindOfClass:aClass];<br>&#125;<br><br>// MARK: NSCopying<br>- (id)copy &#123;<br>  return [self copyWithZone:nil];<br>&#125;<br><br>- (id)copyWithZone:(NSZone *)zone &#123;<br>  return [[JYDynamicColorProxy alloc] initWithDynamicProvider:[self.dynamicProvider copy]];<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> iOS13以下，如果需要切换颜色，该如何刷新？<code>JYDynamicColorProxy</code>是如何存储颜色的呢？</p></blockquote><p>我们<code>swizzle</code>将设置颜色方法进行了hook，例如<code>@selector(setBackgroundColor:);</code>方法，将<code>backgroundColor</code>为<code>JYDynamicColor</code>的都进行处理</p><p>这里采用了关联对象的思想，写了一个<code>UIView</code>的分类,将<code>JYDynamicColorProxy</code>进行存储，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">...<br>@property (nullable, readonly) JYDynamicColor *jy_dynamicBackgroundColor;<br>...<br><br>- (JYDynamicColor *)jy_dynamicBackgroundColor &#123;<br>    return objc_getAssociatedObject(self, @selector(jy_dynamicBackgroundColor));<br>&#125;<br><br>- (void)setJy_dynamicBackgroundColor:(JYDynamicColor *)jy_dynamicBackgroundColor &#123;<br>  objc_setAssociatedObject(self,<br>                           @selector(jy_dynamicBackgroundColor),<br>                           jy_dynamicBackgroundColor,<br>                           OBJC_ASSOCIATION_COPY_NONATOMIC);<br>&#125;<br></code></pre></td></tr></table></figure><p>当修改当前模式的时候，我们将初始化拿到的<code>UIApplication</code>进行遍历，拿到<code>UIView</code>,然后调用分类当中的修改颜色方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (void)jyTraitCollectionDidChange:(JYTraitCollection *)previousTraitCollection &#123;<br>  if (@available(iOS 13.0, *)) &#123;<br>    return;<br>  &#125;<br>    [self.subviews enumerateObjectsUsingBlock:^(__kindof UIView * _Nonnull view, NSUInteger idx, BOOL * _Nonnull stop) &#123;<br>        [view jyTraitCollectionDidChange:previousTraitCollection];<br>     &#125;];<br>     <br>    [self setNeedsLayout];<br>    [self setNeedsDisplay];<br>#if __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_13_0<br>    [self jy_updateDynamicColors];<br>#endif<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">- (void)jy_updateDynamicColors&#123;<br>    JYDynamicColor * backgroundColor = [self jy_dynamicBackgroundColor];<br>    if (backgroundColor) &#123;<br>        [self setBackgroundColor:backgroundColor];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过关联对象取到对应模式的Color,然后赋值即可，图片也是一样的原理</p>]]></content>
    
    
    <categories>
      
      <category>iOS源码</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-渲染机制</title>
    <link href="/2021/04/01/iOS-%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/04/01/iOS-%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="CALayer-与-UIView"><a href="#CALayer-与-UIView" class="headerlink" title="CALayer 与 UIView"></a>CALayer 与 UIView</h3><p>UIView拥有一个属性为<code>layer</code>和<code>layerClass</code>属性</p><ul><li><code>layer</code> 属性返回的是 <code>UIView</code> 所持有的主 <code>Layer(RootLayer)</code> 实例，我们可以通过其来设置 <code>UIView</code> 没有封装的一些 <code>layer</code> 属性；</li><li><code>layerClass</code> 则返回 <code>RootLayer</code> 所使用的类，我们可以通过重写该属性，来让 <code>UIView</code> 使用不同的 <code>CALayer</code> 来显示</li></ul><p><code>CALayer</code>继承自<code>NSObject</code>，负责图像渲染</p><p><code>UIView</code>继承自<code>UIResponder</code>，负责事件的响应</p><h3 id="图像显示原理"><a href="#图像显示原理" class="headerlink" title="图像显示原理"></a>图像显示原理</h3><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024844.png" alt="image-20190312112603570"></p><p>CPU和GPU通过总线连接，CPU中计算出的往往是<code>bitmap</code>位图，通过总线由合适的时机传递给GPU，GPU拿到位图后，渲染到帧缓存区<code>FrameBuffer</code>,然后由视频控制器根据<code>Vsync</code>信号在指定时间之前去帧缓冲区提取内容，显示到屏幕上。</p><p>CPU工作内容: </p><ol><li>layout（UI布局，文本计算）</li><li>display（绘制 drawRect）</li><li>prepare(图片解码)</li><li>commit（提交位图）</li></ol><p><code>GPU工作内容:</code> 顶点着色，图元装配，光栅化，片段着色，片段处理，最后提交帧缓冲区</p><h3 id="View绘制渲染机制和Runloop什么关系"><a href="#View绘制渲染机制和Runloop什么关系" class="headerlink" title="View绘制渲染机制和Runloop什么关系"></a>View绘制渲染机制和Runloop什么关系</h3><p>例如有以下 <code>UIView</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@implementation JYView<br>- (void)drawRect:(CGRect)rect &#123;<br>    CGContextRef con = UIGraphicsGetCurrentContext();<br>    CGContextAddEllipseInRect(con, CGRectMake(0,0,100,200));<br>    CGContextSetRGBFillColor(con, 0, 0, 1, 1);<br>    CGContextFillPath(con);<br>&#125;<br>@end<br><br><br>@implementation ViewController<br><br>- (void)viewDidLoad &#123;<br>    [super viewDidLoad];<br>    JYView *view = [[JYView alloc] init];<br>    view.backgroundColor = [UIColor whiteColor];<br>    view.bounds = CGRectMake(0, 0, 100, 100);<br>    view.center = CGPointMake(100, 100);<br>    [self.view addSubview:view];<br>&#125;<br><br>@end<br></code></pre></td></tr></table></figure><p>重写了 <code>UIView</code> 的 <code>DrawRect</code>方法.展现在屏幕前经历以下堆栈</p><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2020-03-03-093059.jpg" alt="img"></p><h3 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h3><p>当在操作 UI 时，比如改变了<code>Frame</code> 、更新了 <code>UIView/CALayer</code> 的层次时，或者手动调用了 <code>UIView/CALayer</code> 的 <code>setNeedsLayout/setNeedsDisplay</code> 方法后，这个 <code>UIView/CALayer</code> 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数： <code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code>。这个函数里会遍历所有待处理的 UIView&#x2F;CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()<br>QuartzCore:CA::Transaction::observer_callback:<br>CA::Transaction::commit();<br>CA::Context::commit_transaction();<br>CA::Layer::layout_and_display_if_needed();<br>CA::Layer::layout_if_needed();<br>[CALayer layoutSublayers];<br>[UIView layoutSubviews];<br>CA::Layer::display_if_needed();<br>[CALayer display];<br>[UIView drawRect];<br></code></pre></td></tr></table></figure><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2020-03-04-A4.png" alt="img"></p><h3 id="View布局与约束时机"><a href="#View布局与约束时机" class="headerlink" title="View布局与约束时机"></a>View布局与约束时机</h3><p>一个视图的布局指的是它在屏幕上的的大小和位置。每个 view 都有一个 frame 属性，用来表示在父 view 坐标系中的位置和具体的大小。<code>UIView</code> 给你提供了用来通知系统某个 view 布局发生变化的方法，也提供了在 view 布局重新计算后调用的可重写的方法。</p><h4 id="布局"><a href="#布局" class="headerlink" title="布局:"></a>布局:</h4><p><strong>layoutSubviews()</strong></p><p>它负责给出当前 view 和每个子 view 的位置和大小。这个方法很开销很大，因为它会在每个子视图上起作用并且调用它们相应的 <code>layoutSubviews</code> 方法。系统会在任何它需要重新计算视图的 frame 的时候调用这个方法，所以你应该在需要更新 frame 来重新定位或更改大小时重载它。然而你不应该在代码中显式调用这个方法。相反，有许多可以在 run loop 的不同时间点触发 <code>layoutSubviews</code> 调用的机制，这些触发机制比直接调用 <code>layoutSubviews</code> 的资源消耗要小得多。</p><p><strong>自动刷新触发器</strong></p><p>有许多事件会自动给视图打上 “update layout” 标记，因此 <code>layoutSubviews</code> 会在<strong>下一个周期中（重点！！！）</strong>被调用，而不需要开发者手动操作。这些自动通知系统 view 的布局发生变化的方式有：</p><ul><li>修改 view 的大小</li><li>新增 subview</li><li>用户在 <code>UIScrollView</code> 上滚动（<code>layoutSubviews</code> 会在 <code>UIScrollView</code> 和它的父 view 上被调用）</li><li>用户旋转设备</li><li>更新视图的 constraints</li></ul><p>这些方式都会告知系统 view 的位置需要被重新计算，继而会自动转化为一个最终的 <code>layoutSubviews</code> 调用。当然，也有直接触发 <code>layoutSubviews</code> 的方法。</p><p><strong>setNeedsLayout()</strong></p><p>触发 <code>layoutSubviews</code> 调用的最省资源的方法就是在你的视图上调用 <code>setNeedsLaylout</code> 方法。调用这个方法代表向系统表示视图的布局需要重新计算。<code>setNeedsLayout</code> 方法会立刻执行并返回，但在返回前不会真正更新视图。视图会在下一个 update cycle 中更新，就在系统调用视图们的 <code>layoutSubviews</code> 以及他们的所有子视图的 <code>layoutSubviews</code> 方法的时候。</p><p><strong>layoutIfNeeded()</strong></p><p><code>layoutIfNeeded</code> 是另一个会让 <code>UIView</code> 触发 <code>layoutSubviews</code> 的方法。 当视图需要更新的时候，与 <code>setNeedsLayout()</code> 会让视图在下一周期调用 <code>layoutSubviews</code> 更新视图不同，<code>layoutIfNeeded</code> 会立即调用 <code>layoutSubviews</code> 方法。但是如果你调用了 <code>layoutIfNeeded</code> 之后，并且没有任何操作向系统表明需要刷新视图，那么就不会调用 <code>layoutsubview</code>。如果你在同一个 run loop 内调用两次 <code>layoutIfNeeded</code>，并且两次之间没有更新视图，第二个调用同样不会触发 <code>layoutSubviews</code> 方法。</p><p>使用 <code>layoutIfNeeded</code>，则布局和重绘会立即发生并在函数返回之前完成（除非有正在运行中的动画）。这个方法在你需要依赖新布局，无法等到下一次 update cycle 的时候会比 <code>setNeedsLayout</code> 有用</p><p>当对希望通过修改 constraint 进行动画时，这个方法特别有用。你需要在 animation block 之前对 self.view 调用 <code>layoutIfNeeded</code>，以确保在动画开始之前传播所有的布局更新。在 animation block 中设置新 constrait 后，需要再次调用 <code>layoutIfNeeded</code> 来动画到新的状态。</p><p>(<strong>注:</strong> Masonry 动画需要这个)</p><h4 id="显示："><a href="#显示：" class="headerlink" title="显示："></a>显示：</h4><p>一个视图的显示包含了颜色、文本、图片和 Core Graphics 绘制等视图属性，不包括其本身和子视图的大小和位置。和布局的方法类似，显示也有触发更新的方法，它们由系统在检测到更新时被自动调用，或者我们可以手动调用直接刷新。</p><p><strong>setNeedsDisplay()</strong></p><p>这个方法类似于布局中的 <code>setNeedsLayout</code> 。它会给有内容更新的视图设置一个内部的标记，但在视图重绘之前就会返回。然后在下一个 update cycle 中，系统会遍历所有已标标记的视图，并调用它们的 <code>draw</code> 方法。</p><p>大部分时候，在视图中更新任何 UI 组件都会把相应的视图标记为“dirty”，通过设置视图“内部更新标记”，在下一次 update cycle 中就会重绘，而不需要显式的 <code>setNeedsDisplay</code> 调用</p><h4 id="约束："><a href="#约束：" class="headerlink" title="约束："></a>约束：</h4><p><strong>updateConstraints()</strong></p><p>这个方法用来在自动布局中动态改变视图约束。和布局中的 <code>layoutSubviews()</code> 方法或者显示中的 <code>draw</code> 方法类似，<code>updateConstraints()</code> 只应该被重载，<strong>绝不要在代码中显式地调用</strong>。通常你只应该在 <code>updateConstraints</code> 方法中实现必须要更新的约束。</p><p><strong>setNeedsUpdateConstraints()</strong></p><p>调用 <code>setNeedsUpdateConstraints()</code> 会保证在下一次更新周期中更新约束。它通过标记“update constraints”来触发 <code>updateConstraints()</code>。这个方法和 <code>setNeedsDisplay()</code> 以及 <code>setNeedsLayout()</code> 方法的工作机制类似。</p><p><strong>updateConstraintsIfNeeded()</strong></p><p>对于使用自动布局的视图来说，这个方法与 <code>layoutIfNeeded</code> 等价。它会检查 “update constraints”标记（可以被 <code>setNeedsUpdateConstraints</code> 或者 <code>invalidateInstrinsicContentSize</code>方法自动设置）。如果它认为这些约束需要被更新，它会立即触发 <code>updateConstraints()</code> ，<strong>而不会等到 RunLoop 的末尾。</strong></p><h3 id="UI-卡顿-列表卡顿、掉帧原理"><a href="#UI-卡顿-列表卡顿、掉帧原理" class="headerlink" title="UI 卡顿,列表卡顿、掉帧原理"></a>UI 卡顿,列表卡顿、掉帧原理</h3><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024849.png" alt="image-20190312140156990"></p><p>iOS的 <code>mainRunloop</code>是一个60fps的回调，也就是说每16.7ms(VSync信号时间)会绘制一次屏幕，这个时间段内要完成view的缓冲区创建，view内容的绘制（如果重写了drawRect），这些CPU的工作。然后将这个缓冲区交给GPU渲染，这个过程又包括多个view的拼接(compositing)，纹理的渲染（Texture）等，最终显示在屏幕上。整个过程就是我们上面画的流程图。 因此，如果在16.7ms内完不成这些操作，比如，CPU做了太多的工作，或者view层次过于多，图片过于大，导致GPU压力太大，就会导致“卡”的现象，也就是丢帧.</p><blockquote><p>在规定的16.7ms内，在下一个VSync信号到来之前，CPU和GPU并没有共同完成下一帧视频的合成，就会出现掉帧、卡顿。</p></blockquote><h5 id="滑动优化方案思路："><a href="#滑动优化方案思路：" class="headerlink" title="滑动优化方案思路："></a>滑动优化方案思路：</h5><ul><li>CPU：<ul><li>对象的创建、调整、销毁可以放在子线程中去做ASDK；</li><li>预排班。布局计算、文本计算等事先放到子线程中去做；</li><li>使用轻量级对象，比如CALayer代替UIView</li><li>预渲染。文本等异步绘制，图片编解码等。</li><li>控制并发线程数量</li><li>减少重复计算布局，减少修改frame等</li><li>autolayout比frame更消耗资源</li><li>可以让图片的size跟frame一致</li></ul></li><li>GPU：<ul><li>纹理渲染。避免离屏渲染</li><li>视图混合。减少视图层级的复杂性，减少透明视图；不透明的opaque设置为YES</li><li>GPU能处理的最大纹理是4096 * 4096，一旦超过这个尺寸就会调用CPU进行资源处理，所以纹理尽量不要超过这个尺寸</li></ul></li></ul><h3 id="UIView的绘制原理"><a href="#UIView的绘制原理" class="headerlink" title="UIView的绘制原理"></a>UIView的绘制原理</h3><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024854.png" alt="image-20190312141642996"></p><p><code>[UIView setNeedsDisplay]</code> 并没有发生当前视图立即绘制工作,打上需要重绘的脏标记，最后是在某个时机完成</p><p><code>[UIView setLayoutIfNeed]</code> 立即重新布局视图(下一个Runloop)</p><p><code>[view layouIfNeeded]</code> 当前RunLoop休眠前更新</p><p>当我们调用UIView的<code>setNeedsDisplay</code>的方法时候，会调用<code>layer</code>的同名方法，相当于在当前<code>layer</code>打上绘制标记，在当前<code>runloop</code>将要结束的时候，才会调用CALayer的<code>display</code>方法进入到真正的绘制当中。</p><p>CALayer的<code>display</code>方法中，首先会判断layer的delegate方法<code>displayLayer：</code>是否实现，如果代理没有响应这个方法，则进入到系统绘制流程；如果代理响应了这个方法，则进入到异步绘制流程</p><h3 id="系统绘制流程"><a href="#系统绘制流程" class="headerlink" title="系统绘制流程"></a>系统绘制流程</h3><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024857.png" alt="image-20190312142115333"></p><p>在CALayer内部，系统会创建一个backingStore（可以理解为CGContextRef，drawRect中取到的currentRef就是这个东西），然后layer回判断是否有delegate，如果没有代理，就调用CALayer的<code>drawInContext：</code>方法；如果有代理，则调用layer代理的<code>drawLayer:inContext:</code>方法，这一步发生在系统内部，然后在合适的时间给与我们回调一个熟悉的UIView的<code>drawRect：</code>方法。也就是在系统内部的绘制之上，允许我们再做一些额外的绘制。最后CALayer把backting store（位图）传给GPU。</p><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-07-23-134925.jpg" alt="15420320733034"></p><ol><li>首先一个视图由 CPU 进行 Frame 布局，准备视图和图层的层级关系，查询是否有重写 <code>drawRect:</code> 或 <code>drawLayer:inContext:</code>方法，<strong>注意：如果有重写的话，这里的渲染是会占用CPU进行处理的。</strong></li><li>CPU 会将处理视图和图层的层级关系打包，通过 IPC（内部处理通信）通道提交给渲染服务，渲染服务由 OpenGL ES 和 GPU 组成。</li><li>渲染服务首先将图层数据交给 OpenGL ES 进行纹理生成和着色。生成前后帧缓存，再根据显示硬件的刷新频率，一般以设备的Vsync信号和CADisplayLink为标准，进行前后帧缓存的切换。</li><li>最后，将最终要显示在画面上的后帧缓存交给 GPU，进行采集图片和形状，运行变换，应用文理和混合。最终显示在屏幕上。</li></ol><blockquote><p>在iOS中是双缓冲机制，有前帧缓存、后帧缓存，即GPU会预先渲染好一帧放入一个缓冲区内（前帧缓存），让视频控制器读取，当下一帧渲染好后，GPU会直接把视频控制器的指针指向第二个缓冲器（后帧缓存）。当你视频控制器已经读完一帧，准备读下一帧的时候，GPU会等待显示器的VSync信号发出后，前帧缓存和后帧缓存会瞬间切换，后帧缓存会变成新的前帧缓存，同时旧的前帧缓存会变成新的后帧缓存。</p></blockquote><h3 id="异步绘制流程"><a href="#异步绘制流程" class="headerlink" title="异步绘制流程"></a>异步绘制流程</h3><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024902.png" alt="image-20190312142425272"></p><p>layer的delegate如果实现了<code>displayLayer:</code>方法，就会进入到异步绘制的流程。在异步绘制的过程中，需要代理来生成对应的bitmap位图文件，并把此bitmap作为layer的contents属性</p><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2019-03-22-024910.png" alt="image-20190312142514299"></p><h3 id="drawRect方法内为何第一行代码总要获取图形的上下文"><a href="#drawRect方法内为何第一行代码总要获取图形的上下文" class="headerlink" title="drawRect方法内为何第一行代码总要获取图形的上下文"></a>drawRect方法内为何第一行代码总要获取图形的上下文</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">CGContextRef con = UIGraphicsGetCurrentContext();<br></code></pre></td></tr></table></figure><p><img src="http://sylarimage.oss-cn-shenzhen.aliyuncs.com/2020-03-04-082448.jpg" alt="img"></p><p>每一个UIView都有一个layer，每一个layer都有个content，这个content指向的是一块缓存，叫做backing store 当UIView被绘制时（从 CA::Transaction::commit:以后），CPU执行drawRect，通过context将数据写入backing store 当backing store写完后，通过render server交给GPU去渲染，将backing store中的bitmap数据显示在屏幕上 所以在 drawRect 方法中 要首先获取 context</p><h3 id="为什么要将图像渲染和事件响应这两个功能分开？"><a href="#为什么要将图像渲染和事件响应这两个功能分开？" class="headerlink" title="为什么要将图像渲染和事件响应这两个功能分开？"></a>为什么要将图像渲染和事件响应这两个功能分开？</h3><p>因为<code>CALayer</code>属于<code>QuartzCore</code>框架，<code>UIView</code>属于<code>UIKit</code>框架，</p><p><code>QuartzCore</code> 框架是可以跨平台使用的，但是<code>UIKit</code>框架只能在iOS中，在MacOs当中触摸是鼠标键盘，而iOS是触摸事件，遵循设计原则中的单一职责。</p><h3 id="CALayer为什么可以呈现可视化内容呢？"><a href="#CALayer为什么可以呈现可视化内容呢？" class="headerlink" title="CALayer为什么可以呈现可视化内容呢？"></a>CALayer为什么可以呈现可视化内容呢？</h3><p>CALayer包含一个<code>contents</code>属性,<code>CALayer</code> 中的 <code>contents</code> 属性保存了由设备渲染流水线渲染好的位图 <code>bitmap</code>（通常也被称为 <code>backing store</code>），而当设备屏幕进行刷新时，会从 <code>CALayer</code> 中读取生成好的 <code>bitmap</code>，进而呈现到屏幕上。CALayer的<code>contents</code>的值必须是<code>CGImage</code>。</p><h3 id="例如添加一个View-其底层做了什么操作？"><a href="#例如添加一个View-其底层做了什么操作？" class="headerlink" title="例如添加一个View,其底层做了什么操作？"></a>例如添加一个View,其底层做了什么操作？</h3><p><code>Core Animation</code> 会在APP启动时像 <code>Runloop</code> 注册一个 <code>Observer</code>，当事件到来的时候，<code>Runloop</code> 会被唤醒处理相关的业务逻辑（UIView 的创建，修改），将UI信息提交给<code>Render Server</code>,然后会等待<code>VSync</code>信号的到来，然后会通过<code>Metal</code>或者<code>OpenGLES</code>做一些绘制操作，然后把处理完的数据，纹理，顶点，着色器等提交给<code>GPU</code>，在下一个<code>VSync</code>信号到来的时候，视频控制器等读取帧缓冲区的数据显示到屏幕上。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </p><h3 id="界面掉帧是因为什么引起的？"><a href="#界面掉帧是因为什么引起的？" class="headerlink" title="界面掉帧是因为什么引起的？"></a>界面掉帧是因为什么引起的？</h3><p>掉帧是因为当在一个<code>Vsync</code>周期中，<code>CPU</code>或者<code>GPU</code>没有完成内容提交，那么这一帧就会被废弃掉，等待下一个<code>Vsync</code>的到来，而显示屏还会保持之前的内容不变，这也是界面卡顿的原因。</p><h3 id="CoreAnimation渲染流程？"><a href="#CoreAnimation渲染流程？" class="headerlink" title="CoreAnimation渲染流程？"></a>CoreAnimation渲染流程？</h3><p>首先收到事件的处理，例如布局改变</p><p>通过CPU完成显示内容计算，对APP图层进行打包，在下一次runloop时将描述好的 UI 信息以 <code>IPC</code> 的形式提供给<strong>系统常驻的 UI 绘制进程</strong>渲染服务RenderServer, </p><p>将收到的打包进行解码，执行metal相关程序，调用GPU</p><p>GPU完成对图像的渲染，最后显示到屏幕上</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24egy1gzj6f3n9o3j20xc0hq406.jpg"></p><p><strong>但是如果重写了 <code>drawRect:</code> 方法，这个方法会直接调用 <code>Core Graphics</code> 绘制方法得到 <code>bitmap</code> 数据，同时系统会额外申请一块内存，用于暂存绘制好的 <code>bitmap</code>。</strong></p><p>由于重写了 <code>drawRect:</code> 方法，导致绘制过程从 GPU 转移到了 CPU，这就导致了一定的效率损失。与此同时，这个过程会额外使用 CPU 和内存，因此需要高效绘制，否则容易造成 CPU 卡顿或者内存爆炸。</p><h3 id="离屏渲染指的是什么？"><a href="#离屏渲染指的是什么？" class="headerlink" title="离屏渲染指的是什么？"></a>离屏渲染指的是什么？</h3><p>我们知道<code>GPU</code>会将渲染完成后的结果放入<code>Frame Buffer</code>当中，但是如果<code>GPU</code>无法一次完成渲染工作，需要两，这时就需要一个额外的载体来保存第一次的结果，而这个载体也就是离屏渲染缓冲区。</p><p>离屏渲染会创建新的缓冲区，增加额外的空间，大量的离屏渲染可能造成内存的过大压力。</p><p>离屏渲染的过程中，会进行两次上下文的切换，先切换到屏幕外，离屏渲染完成后再切回当前屏幕。</p><h3 id="所有的离屏渲染都是坏的吗？"><a href="#所有的离屏渲染都是坏的吗？" class="headerlink" title="所有的离屏渲染都是坏的吗？"></a>所有的离屏渲染都是坏的吗？</h3><p>我们可以利用开启<code>CALayer</code>的<code>shouldRasterize</code>属性去触发离屏渲染。开启之后，<code>Render Server</code> 会强制将 <code>CALayer 的渲染位图结果</code>bitmap&#96; 保存下来，这样下次再需要渲染时就可以直接复用，从而提高效率。</p><p>保存的 <code>bitmap</code> 包含 <code>layer</code> 的 <code>subLayer</code>、圆角、阴影、组透明度 <code>group opacity</code> 等，所以如果 <code>layer</code> 的构成包含上述几种元素，结构复杂且需要反复利用，那么就可以考虑打开光栅化。<strong>其主旨在于降低性能损失，但总是至少会触发一次离屏渲染。</strong></p><blockquote><p>圆角、阴影、组透明度等会由系统自动触发离屏渲染，那么打开光栅化就可以节约第二次及以后的渲染时间。而多层 subLayer 的情况由于不会自动触发离屏渲染，所以相比之下会多花费第一次离屏渲染的时间，但是可以节约后续的重复渲染的开销。</p></blockquote><h3 id="哪些情况会触发离屏渲染？"><a href="#哪些情况会触发离屏渲染？" class="headerlink" title="哪些情况会触发离屏渲染？"></a>哪些情况会触发离屏渲染？</h3><ul><li>使用了 <code>mask</code> 的 <code>layer (layer.mask)</code>；</li><li>添加了投影的<code> layer (layer.shadow*，表示相关的 shadow 开头的属性)</code></li><li>设置了组透明度为 YES，并且透明度不为 1 的<code>layer (layer.allowsGroupOpacity/layer.opacity)</code></li><li>采用了光栅化的 <code>layer (layer.shouldRasterize)</code></li><li>绘制了文字的 <code>layer (UILabel, CATextLayer, Core Text 等)</code></li><li>需要进行裁剪的<code> layer (layer.masksToBounds / view.clipsToBounds)</code></li></ul><p>总结一下，iOS 9 之后圆角造成离屏渲染的条件包括：</p><ul><li>圆角</li><li>裁剪</li><li><code>layer</code> 的<code>contents</code>不为 <code>nil</code></li><li>设置了背景色 &#x2F; 边框 &#x2F; 其他有图像内容的图层</li></ul><h3 id="知识点问题梳理"><a href="#知识点问题梳理" class="headerlink" title="知识点问题梳理"></a>知识点问题梳理</h3><ul><li><p>图像显示的原理</p></li><li><p>layoutSubviews()&#x2F;setNeedsLayout()&#x2F;layoutIfNeeded()三者之间的区别？</p></li><li><p>setNeedsDisplay()有什么作用？</p></li><li><p>界面掉帧是因为什么引起的？</p></li><li><p>离屏渲染是什么?所有的离屏渲染都是坏的吗？哪些情况会触发离屏渲染？</p></li><li><p>异步绘制的流程</p></li><li><p>drawRect方法在什么时候调用？</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-Runloop</title>
    <link href="/2021/03/01/iOS-Runloop/"/>
    <url>/2021/03/01/iOS-Runloop/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是runloop"><a href="#什么是runloop" class="headerlink" title="什么是runloop"></a>什么是runloop</h3><ul><li>Run loops是线程相关的的基础框架的一部分。一个runloop就是一个事件处理的循环，用来不停的调度工作以及处理输入事件。其实内部就是do－while循环，这个循环内部不断地处理各种任务（比 如Source，Timer，Observer）。使用runloop的目的是让你的线程在有工作的时候忙于工作，而没工作的时候处于休眠状态。</li></ul><h3 id="runloop和线程的关系"><a href="#runloop和线程的关系" class="headerlink" title="runloop和线程的关系"></a>runloop和线程的关系</h3><ul><li>线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。</li><li>子线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。</li><li>子线程中，RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。</li><li>你只能在一个线程的内部获取其 RunLoop（主线程除外）。</li></ul><h3 id="runloop的接口"><a href="#runloop的接口" class="headerlink" title="runloop的接口"></a>runloop的接口</h3><ul><li>CFRunLoopRef<ul><li>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source&#x2F;Timer&#x2F;Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source&#x2F;Timer&#x2F;Observer，让其互不影响</li></ul></li><li>CFRunLoopModeRef</li><li>CFRunLoopSourceRef<ul><li>CFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1。<ul><li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</li><li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</li></ul></li></ul></li><li>CFRunLoopTimerRef<ul><li>CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</li></ul></li><li>CFRunLoopObserverRef<ul><li>CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。</li></ul></li></ul><h3 id="runloop的mode"><a href="#runloop的mode" class="headerlink" title="runloop的mode"></a>runloop的mode</h3><ul><li>kCFRunLoopDefaultMode&#x2F;NSDefaultRunLoopMode<ul><li>App的默认 Mode，通常主线程是在这个 Mode 下运行的。</li></ul></li><li>UITrackingRunLoopMode<ul><li>界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响。</li></ul></li><li>UIInitializationRunLoopMode<ul><li>在刚启动App时第进入的第一个Mode，启动完成后就不再使用</li></ul></li><li>GSEventReceiveRunLoopMode<ul><li>接受系统事件的内部Mode，通常用不到</li></ul></li><li>kCFRunLoopCommonModes&#x2F;NSRunLoopCommonModes<ul><li>组合状态，这是一个占位的 Mode，没有实际作用。</li></ul></li></ul><h3 id="runloop内部逻辑"><a href="#runloop内部逻辑" class="headerlink" title="runloop内部逻辑"></a>runloop内部逻辑</h3><p><img src="http://blog.qiji.tech/wp-content/uploads/2016/04/RunLoop_1.png" alt="image"></p><ul><li>1、通知Observer：即将进入Loop</li><li>2、通知Observer：将要处理Timer</li><li>3、通知Observer：将要处理Source0</li><li>4、处理Source0</li><li>5、如果有Source1，跳到第9步</li><li>6、通知Observer：线程即将休眠</li><li>7、休眠，等待唤醒</li><li>8、通知Observer：线程刚被唤醒</li><li>9、处理唤醒时收到的消息，之后跳回2</li><li>10、通知Observer：即将退出Loop</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs scss">&#123;<br>    <span class="hljs-comment">/// 1. 通知Observers，即将进入RunLoop</span><br>    <span class="hljs-comment">/// 此处有Observer会创建AutoreleasePool: _objc_autoreleasePoolPush();</span><br>    <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopEntry);<br>    do &#123;<br> <br>        <span class="hljs-comment">/// 2. 通知 Observers: 即将触发 Timer 回调。</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopBeforeTimers);<br>        <span class="hljs-comment">/// 3. 通知 Observers: 即将触发 Source (非基于port的,Source0) 回调。</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopBeforeSources);<br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span>(block);<br> <br>        <span class="hljs-comment">/// 4. 触发 Source0 (非基于port的) 回调。</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</span>(source0);<br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span>(block);<br> <br>        <span class="hljs-comment">/// 6. 通知Observers，即将进入休眠</span><br>        <span class="hljs-comment">/// 此处有Observer释放并新建AutoreleasePool: _objc_autoreleasePoolPop(); _objc_autoreleasePoolPush();</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopBeforeWaiting);<br> <br>        <span class="hljs-comment">/// 7. sleep to wait msg.</span><br>        <span class="hljs-built_in">mach_msg</span>() -&gt; <span class="hljs-built_in">mach_msg_trap</span>();<br>        <br> <br>        <span class="hljs-comment">/// 8. 通知Observers，线程被唤醒</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopAfterWaiting);<br> <br>        <span class="hljs-comment">/// 9. 如果是被Timer唤醒的，回调Timer</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</span>(timer);<br> <br>        <span class="hljs-comment">/// 9. 如果是被dispatch唤醒的，执行所有调用 dispatch_async 等方法放入main queue 的 block</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__</span>(dispatched_block);<br> <br>        <span class="hljs-comment">/// 9. 如果如果Runloop是被 Source1 (基于port的) 的事件唤醒了，处理这个事件</span><br>        <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span>(source1);<br> <br> <br>    &#125; while (...);<br> <br>    <span class="hljs-comment">/// 10. 通知Observers，即将退出RunLoop</span><br>    <span class="hljs-comment">/// 此处有Observer释放AutoreleasePool: _objc_autoreleasePoolPop();</span><br>    <span class="hljs-built_in">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(kCFRunLoopExit);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h2><h3 id="runloop什么时候退出"><a href="#runloop什么时候退出" class="headerlink" title="runloop什么时候退出"></a>runloop什么时候退出</h3><ul><li>1、超过设定的超时</li><li>2、当前runloop中没有需要处理的timer、source</li><li>3、接收到exit信号</li></ul><h2 id="runloop在系统中的应用"><a href="#runloop在系统中的应用" class="headerlink" title="runloop在系统中的应用"></a>runloop在系统中的应用</h2><h3 id="1、AutoreleasePool"><a href="#1、AutoreleasePool" class="headerlink" title="1、AutoreleasePool"></a>1、AutoreleasePool</h3><p>App启动后，苹果在主线程 RunLoop 里注册了两个 Observer，其回调都是 _wrapRunLoopWithAutoreleasePoolHandler()。</p><p>第一个 Observer 监视的事件是 Entry(即将进入Loop)，其回调内会调用 _objc_autoreleasePoolPush() 创建自动释放池。其 order 是-2147483647，优先级最高，保证创建释放池发生在其他所有回调之前。</p><p>第二个 Observer 监视了两个事件： BeforeWaiting(准备进入休眠) 时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池；Exit(即将退出Loop) 时调用 _objc_autoreleasePoolPop() 来释放自动释放池。这个 Observer 的 order 是 2147483647，优先级最低，保证其释放池子发生在其他所有回调之后。</p><p>在主线程执行的代码，通常是写在诸如事件回调、Timer回调内的。这些回调会被 RunLoop 创建好的 AutoreleasePool 环绕着，所以不会出现内存泄漏，开发者也不必显示创建 Pool 了。</p><h3 id="2、事件响应"><a href="#2、事件响应" class="headerlink" title="2、事件响应"></a>2、事件响应</h3><p>苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 <code>__IOHIDEventSystemClientQueueCallback()</code></p><p>当一个硬件事件(触摸&#x2F;锁屏&#x2F;摇晃等)发生后，首先由 <code>IOKit.framework</code> 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键(锁屏&#x2F;静音等)，触摸，加速，接近传感器等几种 Event，随后用 <code>mach port</code> 转发给需要的App进程。随后苹果在APP内注册的 Source1 就会触发回调，并调用<code>_UIApplicationHandleEventQueue() </code>进行应用内部的分发。</p><p><code>_UIApplicationHandleEventQueue()</code> 会把 <code>IOHIDEvent </code>处理并包装成 <code>UIEvent</code> 进行处理或分发，其中包括识别 UIGesture&#x2F;处理屏幕旋转&#x2F;发送给 UIWindow 等。通常事件比如 <code>UIButton 点击、touchesBegin/Move/End/Cancel </code>事件都是在这个回调中完成的。</p><h3 id="3、手势识别"><a href="#3、手势识别" class="headerlink" title="3、手势识别"></a>3、手势识别</h3><p>当上面的 <code>_UIApplicationHandleEventQueue() </code>识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin&#x2F;Move&#x2F;End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。</p><p>苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 <code>_UIGestureRecognizerUpdateObserver()</code>，其内部会获取所有刚被标记为待处理的 <code>GestureRecognizer</code>，并执行<code>GestureRecognizer</code>的回调。</p><p>当有 UIGestureRecognizer 的变化(创建&#x2F;销毁&#x2F;状态改变)时，这个回调都会进行相应处理。</p><h3 id="4、界面更新"><a href="#4、界面更新" class="headerlink" title="4、界面更新"></a>4、界面更新</h3><p>当在操作 UI 时，比如改变了 Frame、更新了 UIView&#x2F;CALayer 的层次时，或者手动调用了 UIView&#x2F;CALayer 的 <code>setNeedsLayout/setNeedsDisplay</code>方法后，这个 UIView&#x2F;CALayer 就被标记为待处理，并被提交到一个全局的容器去。</p><p>苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数：<br><code>_ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()</code>。这个函数里会遍历所有待处理的 UIView&#x2F;CAlayer 以执行实际的绘制和调整，并更新 UI 界面。</p><h3 id="5、定时器"><a href="#5、定时器" class="headerlink" title="5、定时器"></a>5、定时器</h3><p>NSTimer 其实就是 CFRunLoopTimerRef，他们之间是 toll-free bridged 的。一个 NSTimer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。例如 10:00, 10:10, 10:20 这几个时间点。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。</p><p>如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。</p><p>CADisplayLink 是一个和屏幕刷新率一致的定时器（但实际实现原理更复杂，和 NSTimer 并不一样，其内部实际是操作了一个 Source）。如果在两次屏幕刷新之间执行了一个长任务，那其中就会有一帧被跳过去（和 NSTimer 相似），造成界面卡顿的感觉。在快速滑动TableView时，即使一帧的卡顿也会让用户有所察觉。Facebook 开源的 AsyncDisplayLink 就是为了解决界面卡顿的问题，其内部也用到了 RunLoop，这个稍后我会再单独写一页博客来分析。</p><h3 id="6、PerformSelecter"><a href="#6、PerformSelecter" class="headerlink" title="6、PerformSelecter"></a>6、PerformSelecter</h3><p>当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。</p><p>当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。</p><h3 id="7、网络请求（现在的NSURLSession是否借助了runloop？）"><a href="#7、网络请求（现在的NSURLSession是否借助了runloop？）" class="headerlink" title="7、网络请求（现在的NSURLSession是否借助了runloop？）"></a>7、网络请求（现在的NSURLSession是否借助了runloop？）</h3><p>NSURLConnection 的工作过程也借助了runloop。使用 NSURLConnection 时，你会传入一个 Delegate，当调用了 [connection start] 后，这个 Delegate 就会不停收到事件回调。实际上，start 这个函数的内部会会获取 CurrentRunLoop，然后在其中的 DefaultMode 添加了4个 Source0 (即需要手动触发的Source)。CFMultiplexerSource 是负责各种 Delegate 回调的，CFHTTPCookieStorage 是处理各种 Cookie 的。</p><p>当开始网络传输时，我们可以看到 NSURLConnection 创建了两个新线程：com.apple.NSURLConnectionLoader 和 com.apple.CFSocket.private。其中 CFSocket 线程是处理底层 socket 连接的。NSURLConnectionLoader 这个线程内部会使用 RunLoop 来接收底层 socket 的事件，并通过之前添加的 Source0 通知到上层的 Delegate。</p><p><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_network.png" alt="image"></p><p>NSURLConnectionLoader 中的 RunLoop 通过一些基于 mach port 的 Source 接收来自底层 CFSocket 的通知。当收到通知后，其会在合适的时机向 CFMultiplexerSource 等 Source0 发送通知，同时唤醒 Delegate 线程的 RunLoop 来让其处理这些通知。CFMultiplexerSource 会在 Delegate 线程的 RunLoop 对 Delegate 执行实际的回调。</p><h2 id="你用runloop实现了什么"><a href="#你用runloop实现了什么" class="headerlink" title="你用runloop实现了什么"></a>你用runloop实现了什么</h2><h3 id="使用runloop开启一个常驻子线程"><a href="#使用runloop开启一个常驻子线程" class="headerlink" title="使用runloop开启一个常驻子线程"></a>使用runloop开启一个常驻子线程</h3><ul><li>AFNetworking2开启子线程，在后台线程接收 Delegate 回调  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C">+ (<span class="hljs-type">void</span>)networkRequestThreadEntryPoint:(id)__unused object &#123;<br> <br>     @autoreleasepool &#123;<br>       [[NSThread currentThread] setName:@<span class="hljs-string">&quot;AFNetworking&quot;</span>];<br>       NSRunLoop *runLoop = [NSRunLoop currentRunLoop];<br>       [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];<br>       [runLoop run];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>线上实时卡顿监控<ul><li>NSRunLoop调用方法主要就是在kCFRunLoopBeforeSources（3. 通知 Observers: 即将触发 Source0回调）和kCFRunLoopBeforeWaiting（6. 通知Observers，即将进入休眠）之间,还有kCFRunLoopAfterWaiting之后,也就是如果我们发现这两个时间内耗时太长,那么就可以判定出此时主线程卡顿</li><li><a href="https://www.jianshu.com/p/890d1ba05f4c">iOS线上实时卡顿监控</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-动态库与静态库的区别</title>
    <link href="/2021/02/16/%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/02/16/%E5%8A%A8%E6%80%81%E5%BA%93%E4%B8%8E%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="静态库-Static-Library"><a href="#静态库-Static-Library" class="headerlink" title="静态库 (Static Library)"></a>静态库 (Static Library)</h3><ul><li><p>分发文件大</p></li><li><p>静态库默认仅将有用到的类文件<code>link</code>到<code>Mach-O</code>中(已类文件为最小链接单位)</p></li><li><p>ipa包小(为了APP瘦身，尽量将代码放静态库中) </p><ul><li>静态库中某个目标文件的代码没有被任何地方引用，则这个目标文件不会被链接到可执行文件中去(前提是不要使用<code>-Objc</code>和<code>-all_load</code>选项，分类代码经常被优化掉，一般都使用<code>-force_load</code>来处理静态库分类加载问题)</li></ul></li><li><p>APP冷启动速度快</p><ul><li>前提是不使用<code>动态库拆分</code>搭配<code>动态库懒加载方案</code></li><li>APP启动流程中有<code>rebase</code>和<code>bind</code>，多个静态库只需要<code>rebase</code>和<code>bind</code>一次</li></ul></li><li><p>存在符号冲突可能</p></li><li><p>共享<code>TEXT段</code></p><ul><li>iOS9以前单个Mach-O的TEXT限制60M</li><li>iOS9以后单个Mach-O的TEXT限制500M</li></ul></li><li><p>不需要额外签名验证  </p></li><li><p>静态库符号的可见性可以在链接期间被修改 </p></li><li><p>文件格式多为<code>fat</code>格式的静态库文件</p></li><li><p>形式多为<code>.a</code>与<code>.framework</code></p></li><li><p>静态库不含<code>bitcode</code>时，引用静态库的目标部署时就不能包含<code>bitcode</code></p></li></ul><h3 id="动态库-Dynamic-Library"><a href="#动态库-Dynamic-Library" class="headerlink" title="动态库 (Dynamic Library)"></a>动态库 (Dynamic Library)</h3><ul><li><p>分发文件小</p></li><li><p>ipa包大  （前提是不考虑懒加载的情况）</p><ul><li>动态库会把整个<code>lib</code>复制进<code>ipa</code>中</li></ul></li><li><p>APP冷启动速度慢</p><ul><li>APP启动流程中有<code>rebase</code>和<code>bind</code>，多个动态库只需要多次<code>rebase</code>和<code>bind</code></li></ul></li><li><p>需要设置合适的<code>runpath</code> </p></li><li><p>需要动态加载</p></li><li><p>需要签名且需要验证签名</p><ul><li>会检查<code>framework</code>的签名，签名中必须包含<code>TeamIdentifier</code>,并且<code>framework</code>和host APP的<code>TeamIdentifier</code>必须一致</li><li>Xcode重签命，保证动态库签名一致性</li></ul></li><li><p>需要导出符号</p></li><li><p>重复的<code>arch</code>结构</p></li><li><p>APP与动态库中重复代码可以共存，不会发生符号冲突</p><ul><li>因为可执行文件在构建链接阶段，遇到静态库则吸附进来，遇到动态库则打个标记，彼此保持独立性</li><li>对于来自动态库的符号，编译器会打个标记，交给<code>dyld</code>去加载和链接符号，也就是把链接的过程推迟到了运行时执行。（比如APP使用的是3.0版本SDK，动态库使用的是1.0版本SDK，能正常运行，但是会有风险）</li></ul></li><li><p>链接后需要包含分发大小</p></li><li><p>冷启动过程中，默认会在<code>main</code>函数之前加载</p><ul><li>默认情况下，过多的动态库会拖慢冷启动速度</li><li>如果采用懒加载动态库的形式，能够加快APP的启动速度,可以使用<code>dlopen</code>和<code>bundle</code>懒加载优化</li></ul></li><li><p>文件格式<code>Mach-O</code>（一个没有<code>main</code>函数的可执行文件）</p></li><li><p>动态库不包含<code>bitcode</code>时，引用动态库的目标部署时可以包含<code>bitcode</code></p></li><li><p><code>CocoaPods</code>从<code>v0.36.0</code>开始，可添加关键字<code>use_frameworks!</code>编译成类似<code>Embedded Framework</code>的结构（可以称之为<code>umbrella framework</code>）</p><ul><li>缺点：默认把项目的依赖全部改为动态库（可是使用<code>use_modular_headers!</code>,也可以在<code>podsepc</code>添加<code>s.static_framework = true</code>规避）</li><li><code>CocoaPods</code>执行脚本把动态库嵌入到<code>.app</code>的<code>Framework</code>目录下（相当于在<code>Embedded Binaries</code>加入动态库）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络</title>
    <link href="/2020/08/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <url>/2020/08/01/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<hr><h3 id="简述OSI七层协议"><a href="#简述OSI七层协议" class="headerlink" title="简述OSI七层协议"></a>简述OSI七层协议</h3><ul><li>OSI七层协议包括：物理层，数据链路层，网络层，运输层，会话层，表示层， 应用层</li></ul><hr><hr><h3 id="简述TCP-x2F-IP五层协议"><a href="#简述TCP-x2F-IP五层协议" class="headerlink" title="简述TCP&#x2F;IP五层协议"></a>简述TCP&#x2F;IP五层协议</h3><ul><li>TCP&#x2F;IP五层协议包括：物理层，数据链路层，网络层，运输层，应用层</li></ul><hr><hr><h3 id="物理层有什么作用"><a href="#物理层有什么作用" class="headerlink" title="物理层有什么作用"></a>物理层有什么作用</h3><ul><li>主要解决两台物理机之间的通信，通过二进制比特流的传输来实现，二进制数据表现为电流电压上的强弱，到达目的地再转化为二进制机器码。网卡、集线器工作在这一层。</li></ul><hr><hr><h3 id="数据链路层有什么作用"><a href="#数据链路层有什么作用" class="headerlink" title="数据链路层有什么作用"></a>数据链路层有什么作用</h3><ul><li>在不可靠的物理介质上提供可靠的传输，接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层。这一层在物理层提供的比特流的基础上，通过差错控制、流量控制方法，使有差错的物理线路变为无差错的数据链路。提供物理地址寻址功能。交换机工作在这一层。</li></ul><hr><hr><h3 id="网络层有什么作用"><a href="#网络层有什么作用" class="headerlink" title="网络层有什么作用"></a>网络层有什么作用</h3><ul><li>将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方，通过路由选择算法为分组通过通信子网选择最佳路径。路由器工作在这一层。</li></ul><hr><hr><h3 id="传输层有什么作用"><a href="#传输层有什么作用" class="headerlink" title="传输层有什么作用"></a>传输层有什么作用</h3><ul><li>传输层提供了进程间的逻辑通信，传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个传输层实体之间有一条端到端的逻辑通信信道。</li></ul><hr><hr><h3 id="会话层有什么作用"><a href="#会话层有什么作用" class="headerlink" title="会话层有什么作用"></a>会话层有什么作用</h3><ul><li>建立会话：身份验证，权限鉴定等；保持会话：对该会话进行维护，在会话维持期间两者可以随时使用这条会话传输局；断开会话：当应用程序或应用层规定的超时时间到期后，OSI会话层才会释放这条会话。</li></ul><hr><hr><h3 id="表示层有什么作用"><a href="#表示层有什么作用" class="headerlink" title="表示层有什么作用"></a>表示层有什么作用</h3><ul><li>对数据格式进行编译，对收到或发出的数据根据应用层的特征进行处理，如处理为文字、图片、音频、视频、文档等，还可以对压缩文件进行解压缩、对加密文件进行解密等。</li></ul><hr><hr><h3 id="应用层有什么作用"><a href="#应用层有什么作用" class="headerlink" title="应用层有什么作用"></a>应用层有什么作用</h3><ul><li>提供应用层协议，如HTTP协议，FTP协议等等，方便应用程序之间进行通信。</li></ul><hr><hr><h3 id="TCP与UDP区别"><a href="#TCP与UDP区别" class="headerlink" title="TCP与UDP区别"></a>TCP与UDP区别</h3><ul><li>TCP作为面向流的协议，提供可靠的、面向连接的运输服务，并且提供点对点通信 </li><li></li><li>UDP作为面向报文的协议，不提供可靠交付，并且不需要连接，不仅仅对点对点，也支持多播和广播</li></ul><hr><hr><h3 id="为何TCP可靠"><a href="#为何TCP可靠" class="headerlink" title="为何TCP可靠"></a>为何TCP可靠</h3><ul><li>TCP有三次握手建立连接，四次挥手关闭连接的机制。除此之外还有滑动窗口和拥塞控制算法。最最关键的是还保留超时重传的机制。对于每份报文也存在校验，保证每份报文可靠性。</li></ul><hr><hr><h3 id="为何UDP不可靠"><a href="#为何UDP不可靠" class="headerlink" title="为何UDP不可靠"></a>为何UDP不可靠</h3><ul><li>UDP面向数据报无连接的，数据报发出去，就不保留数据备份了。仅仅在IP数据报头部加入校验和复用。UDP没有服务器和客户端的概念。UDP报文过长的话是交给IP切成小段，如果某段报废报文就废了。</li></ul><hr><hr><h3 id="简述TCP粘包现象"><a href="#简述TCP粘包现象" class="headerlink" title="简述TCP粘包现象"></a>简述TCP粘包现象</h3><ul><li>TCP是面向流协议，发送的单位是字节流，因此会将多个小尺寸数据被封装在一个tcp报文中发出去的可能性。可以简单的理解成客户端调用了两次send，服务器端一个recv就把信息都读出来了。</li></ul><h3 id="TCP粘包现象处理方法"><a href="#TCP粘包现象处理方法" class="headerlink" title="TCP粘包现象处理方法"></a>TCP粘包现象处理方法</h3><ul><li>固定发送信息长度，或在两个信息之间加入分隔符。</li></ul><hr><hr><h3 id="简述TCP协议的滑动窗口"><a href="#简述TCP协议的滑动窗口" class="headerlink" title="简述TCP协议的滑动窗口"></a>简述TCP协议的滑动窗口</h3><ul><li>滑动窗口是传输层进行流量控制的一种措施，接收方通过通告发 送方自己的窗口大小，从而控制发送方的发送速度，防止发送方发送速度过快而导致自己被淹没。</li></ul><h3 id="简述TCP协议的拥塞控制"><a href="#简述TCP协议的拥塞控制" class="headerlink" title="简述TCP协议的拥塞控制"></a>简述TCP协议的拥塞控制</h3><ul><li><p>拥塞是指一个或者多个交换点的数据报超载，TCP又会有重传机制，导致过载。为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量.</p></li><li><p>当cwnd &lt; ssthresh 时，使用慢开始算法。当cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。当cwnd &#x3D; ssthresh 时，即可使用慢开始算法，也可使用拥塞避免算法。</p></li><li><p>慢开始：由小到大逐渐增加拥塞窗口的大小，每接一次报文，cwnd指数增加。</p></li><li><p>拥塞避免：cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1。</p></li><li><p>快恢复之前的策略：发送方判断网络出现拥塞，就把ssthresh设置为出现拥塞时发送方窗口值的一半，继续执行慢开始，之后进行拥塞避免。</p></li><li><p>快恢复：发送方判断网络出现拥塞，就把ssthresh设置为出现拥塞时发送方窗口值的一半，并把cwnd设置为ssthresh的一半，之后进行拥塞避免。</p></li></ul><hr><hr><h3 id="简述快重传"><a href="#简述快重传" class="headerlink" title="简述快重传"></a>简述快重传</h3><ul><li>如果在超时重传定时器溢出之前，接收到连续的三个重复冗余ACK，发送端便知晓哪个报文段在传输过程中丢失了，于是重发该报文段，不需要等待超时重传定时器溢出再发送该报文。</li></ul><hr><hr><h3 id="TCP三次握手过程"><a href="#TCP三次握手过程" class="headerlink" title="TCP三次握手过程"></a>TCP三次握手过程</h3><ul><li>第一次握手:客户端将标志位SYN置为1，随机产生一个值序列号seq&#x3D;x，并将该数据包发送给服务端，客户端 进入syn_sent状态，等待服务端确认。</li><li>第二次握手:服务端收到数据包后由标志位SYN&#x3D;1知道客户端请求建立连接，服务端将标志位SYN和 ACK都置为1，ack&#x3D;x+1,随机产生一个值seq&#x3D;y，并将该数据包发送给客户端以确认连接请求，服务端进入syn_rcvd状态。</li><li>第三次握手:客户端收到确认后检查,如果正确则将标志位ACK为1，ack&#x3D;y+1，并将该数据包发送给服务端，服务端进行检查如果正确则连接建立成功，客户端和服务端进入established状态，完成三次握手，随后客户端和服务端之间可以开始传输 数据了</li></ul><hr><hr><h3 id="简述半连接队列"><a href="#简述半连接队列" class="headerlink" title="简述半连接队列"></a>简述半连接队列</h3><ul><li>TCP握手中，当服务器处于SYN_RCVD 状态，服务器会把此种状态下请求连接放在一个队列里，该队列称为半连接队列。</li></ul><hr><hr><h3 id="简述SYN攻击"><a href="#简述SYN攻击" class="headerlink" title="简述SYN攻击"></a>简述SYN攻击</h3><ul><li>SYN攻击即利用TCP协议缺陷，通过发送大量的半连接请求，占用半连接队列，耗费CPU和内存资源。</li></ul><h4 id="优化方式："><a href="#优化方式：" class="headerlink" title="优化方式："></a>优化方式：</h4><ul><li>缩短SYN Timeout时间<br>记录IP，若连续受到某个IP的重复SYN报文，从这个IP地址来的包会被一概丢弃。</li></ul><hr><hr><h3 id="TCP四次挥手过程"><a href="#TCP四次挥手过程" class="headerlink" title="TCP四次挥手过程"></a>TCP四次挥手过程</h3><ul><li>第一次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入fin_wait_1状态。</li><li>第二次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1，服务端进入Close_wait状态。此时TCP连接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。</li><li>第三次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入Last_ack状态。</li><li>第四次挥手：客户端收到FIN后，客户端进入Time_wait状态，接着发送一个ACK给服务端，确认后，服务端进入Closed状态，完成四次挥手。</li></ul><hr><hr><h3 id="为什么TCP挥手需要4次"><a href="#为什么TCP挥手需要4次" class="headerlink" title="为什么TCP挥手需要4次"></a>为什么TCP挥手需要4次</h3><ul><li><p>主要原因是当服务端收到客户端的 FIN 数据包后，服务端可能还有数据没发完，不会立即close。</p></li><li><p>所以服务端会先将 ACK 发过去告诉客户端我收到你的断开请求了，但请再给我一点时间，这段时间用来发送剩下的数据报文，发完之后再将 FIN 包发给客户端表示现在可以断了。之后客户端需要收到 FIN 包后发送 ACK 确认断开信息给服务端。</p></li></ul><h3 id="为什么四次挥手释放连接时需要等待2MSL"><a href="#为什么四次挥手释放连接时需要等待2MSL" class="headerlink" title="为什么四次挥手释放连接时需要等待2MSL"></a>为什么四次挥手释放连接时需要等待2MSL</h3><ul><li>MSL即报文最大生存时间。设置2MSL可以保证上一次连接的报文已经在网络中消失，不会出现与新TCP连接报文冲突的情况。</li></ul><hr><hr><h3 id="简述DNS协议"><a href="#简述DNS协议" class="headerlink" title="简述DNS协议"></a>简述DNS协议</h3><ul><li>DNS协议是基于UDP的应用层协议，它的功能是根据用户输入的域名，解析出该域名对应的IP地址，从而给客户端进行访问。</li></ul><h3 id="简述DNS解析过程"><a href="#简述DNS解析过程" class="headerlink" title="简述DNS解析过程"></a>简述DNS解析过程</h3><ol><li><p>客户机发出查询请求，在本地计算机缓存查找，若没有找到，就会将请求发送给dns服务器</p></li><li><p>本地dns服务器会在自己的区域里面查找，找到即根据此记录进行解析，若没有找到，就会在本地的缓存里面查找</p></li><li><p>本地服务器没有找到客户机查询的信息，就会将此请求发送到根域名dns服务器</p></li><li><p>根域名服务器解析客户机请求的根域部分，它把包含的下一级的dns服务器的地址返回到客户机的dns服务器地址</p></li><li><p>客户机的dns服务器根据返回的信息接着访问下一级的dns服务器</p></li><li><p>这样递归的方法一级一级接近查询的目标，最后在有目标域名的服务器上面得到相应的IP信息</p></li><li><p>客户机的本地的dns服务器会将查询结果返回给我们的客户机</p></li><li><p>客户机根据得到的ip信息访问目标主机，完成解析过程</p></li></ol><hr><hr><h3 id="简述HTTP协议"><a href="#简述HTTP协议" class="headerlink" title="简述HTTP协议"></a>简述HTTP协议</h3><ul><li>http协议是超文本传输协议。它是基于TCP协议的应用层传输协议，即客户端和服务端进行数据传输的一种规则。该协议本身HTTP 是一种无状态的协议。</li></ul><hr><hr><h3 id="简述cookie"><a href="#简述cookie" class="headerlink" title="简述cookie"></a>简述cookie</h3><ul><li><p>HTTP 协议本身是无状态的，为了使其能处理更加复杂的逻辑，HTTP&#x2F;1.1 引入 Cookie 来保存状态信息。</p></li><li><p>Cookie是由服务端产生的，再发送给客户端保存，当客户端再次访问的时候，服务器可根据cookie辨识客户端是哪个，以此可以做个性化推送，免账号密码登录等等。</p></li></ul><hr><hr><h3 id="简述session"><a href="#简述session" class="headerlink" title="简述session"></a>简述session</h3><ul><li>session用于标记特定客户端信息，存在在服务器的一个文件里。一般客户端带Cookie对服务器进行访问，可通过cookie中的session id从整个session中查询到服务器记录的关于客户端的信息。</li></ul><h3 id="简述http状态码和对应的信息"><a href="#简述http状态码和对应的信息" class="headerlink" title="简述http状态码和对应的信息"></a>简述http状态码和对应的信息</h3><ul><li><p>1XX：接收的信息正在处理</p></li><li><p>2XX：请求正常处理完毕</p></li><li><p>3XX：重定向</p></li><li><p>4XX：客户端错误</p></li><li><p>5XX：服务端错误</p></li><li><p>常见错误码：301：永久重定向 302：临时重定向 304：资源没修改，用之前缓存就行 400：客户端请求的报文有错误 403：表示服务器禁止访问资源 404：表示请求的资源在服务器上不存在或未找到</p></li><li><p>转发和重定向的区别<br>转发是服务器行为。服务器直接向目标地址访问URL,将相应内容读取之后发给浏览器，用户浏览器地址栏URL不变，转发页面和转发到的页面可以共享request里面的数据。</p></li><li><p>重定向是利用服务器返回的状态码来实现的，如果服务器返回301或者302，浏览器收到新的消息后自动跳转到新的网址重新请求资源。用户的地址栏url会发生改变，而且不能共享数据。</p></li></ul><hr><hr><ul><li><p>简述http1.0<br>规定了请求头和请求尾，响应头和响应尾（get post）</p></li><li><p>每一个请求都是一个单独的连接，做不到连接的复用</p></li></ul><hr><hr><h3 id="简述http1-1的改进"><a href="#简述http1-1的改进" class="headerlink" title="简述http1.1的改进"></a>简述http1.1的改进</h3><ul><li><p>HTTP1.1默认开启长连接，在一个TCP连接上可以传送多个HTTP请求和响应。使用 TCP 长连接的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</p></li><li><p>支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</p></li><li><p>服务端无法主动push</p></li></ul><hr><hr><h3 id="简述HTTP短连接与长连接区别"><a href="#简述HTTP短连接与长连接区别" class="headerlink" title="简述HTTP短连接与长连接区别"></a>简述HTTP短连接与长连接区别</h3><p>HTTP中的长连接短连接指HTTP底层TCP的连接。</p><ul><li><p>短连接：客户端与服务器进行一次HTTP连接操作，就进行一次TCP连接，连接结束TCP关闭连接。</p></li><li><p>长连接：如果HTTP头部带有参数keep-alive，即开启长连接网页完成打开后，底层用于传输数据的TCP连接不会直接关闭，会根据服务器设置的保持时间保持连接，保持时间过后连接关闭。</p></li></ul><hr><hr><h3 id="简述http2-0的改进"><a href="#简述http2-0的改进" class="headerlink" title="简述http2.0的改进"></a>简述http2.0的改进</h3><ul><li><p>提出多路复用。多路复用前，文件时串行传输的，请求a文件，b文件只能等待，并且连接数过多。引入多路复用，a文件b文件可以同时传输。</p></li><li><p>引入了二进制数据帧。其中帧对数据进行顺序标识，有了序列id，服务器就可以进行并行传输数据。</p></li></ul><h3 id="http与https的区别"><a href="#http与https的区别" class="headerlink" title="http与https的区别"></a>http与https的区别</h3><ul><li>http所有传输的内容都是明文，并且客户端和服务器端都无法验证对方的身份。https具有安全性的ssl加密传输协议，加密采用对称加密， https协议需要到ca申请证书，一般免费证书很少，需要交费。</li></ul><hr><hr><h3 id="简述TLS-x2F-SSL-HTTP-HTTPS的关系"><a href="#简述TLS-x2F-SSL-HTTP-HTTPS的关系" class="headerlink" title="简述TLS&#x2F;SSL, HTTP, HTTPS的关系"></a>简述TLS&#x2F;SSL, HTTP, HTTPS的关系</h3><ul><li><p>SSL全称为Secure Sockets Layer即安全套接层，其继任为TLSTransport Layer Security传输层安全协议，均用于在传输层为数据通讯提供安全支持。</p></li><li><p>可以将HTTPS协议简单理解为HTTP协议＋TLS&#x2F;SSL</p></li></ul><hr><hr><h3 id="https的连接过程"><a href="#https的连接过程" class="headerlink" title="https的连接过程"></a>https的连接过程</h3><ul><li><p>浏览器将支持的加密算法信息发给服务器<br>服务器选择一套浏览器支持的加密算法，以证书的形式回发给浏览器<br>客户端(SSL&#x2F;TLS)解析证书验证证书合法性，生成对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，用服务器的公钥对客户端密钥进行非对称加密。<br>客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端对称密钥发送给服务器<br>服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。<br>服务器将加密后的密文发送给客户端<br>客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成<br>Get与Post区别<br>Get：指定资源请求数据，刷新无害，Get请求的数据会附加到URL中，传输数据的大小受到url的限制。</p></li><li><p>Post：向指定资源提交要被处理的数据。刷新会使数据会被重复提交。post在发送数据前会先将请求头发送给服务器进行确认，然后才真正发送数据。</p></li><li><p>Get方法参数有大小限制吗<br>一般HTTP协议里并不限制参数大小限制。但一般由于get请求是直接附加到地址栏里面的，由于浏览器地址栏有长度限制，因此使GET请求在浏览器实现层面上看会有长度限制。</p></li></ul><h3 id="了解REST-API吗"><a href="#了解REST-API吗" class="headerlink" title="了解REST API吗"></a>了解REST API吗</h3><ul><li><p>REST API全称为表述性状态转移（Representational State Transfer，REST）即利用HTTP中get、post、put、delete以及其他的HTTP方法构成REST中数据资源的增删改查操作：</p></li><li><p>Create ：POST<br>Read ：GET<br>Update ：PUT&#x2F;PATCH<br>Delete：DELETE<br>浏览器中输入一个网址后，具体发生了什么<br>进行DNS解析操作，根据DNS解析的结果查到服务器IP地址<br>通过ip寻址和arp，找到服务器，并利用三次握手建立TCP连接<br>浏览器生成HTTP报文，发送HTTP请求，等待服务器响应<br>服务器处理请求，并返回给浏览器<br>根据HTTP是否开启长连接，进行TCP的挥手过程<br>浏览器根据收到的静态资源进行页面渲染</p></li></ul><hr><hr><h3 id="HTTPS相关"><a href="#HTTPS相关" class="headerlink" title="HTTPS相关"></a>HTTPS相关</h3><p>1）HTTPS 结合使用了 非对称加密算法，对称加密算法，hash算法，分别利用他们的优势，避免他们的缺点。利用非对称加密算法获得对称加密算法的秘钥，保证他的安全性；然后实际的网页内容的加密使用的是对称加密算法，利用了对称加密算法速度快的优势，hash算法主要是防止篡改的发生，是一种校验机制，最后数字证书，保证了服务器在将非对称加密算法的公钥传给浏览器时的安全性(不会被中间人篡改)，同时也标志了服务器的身份。</p><p>2）HTTPS的四大金刚：</p><p>非对称加密算法(对称加密算法的秘钥) + 对称加密算法(加密内容) + 数字证书(防止篡改非对称加密算法的公钥) + HASH算法(防止篡改消息)&#x3D;&#x3D; HTTPS</p><p>3）HTTPS的本质是什么？</p><p>HTTPS的本质就是在HTTP连接发起之前，先使用SSL&#x2F;TLS协议，协调客户端和服务端，在两端各自生产一个对称加密算法的秘钥，</p><p>然后使用普通的HTTP协议传输 经过对称加密算法加密的网页内容。因为对称加密算法的秘钥是安全的，所以对称加密算法加密的网页内容也是安全的。</p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-同步方案（锁）</title>
    <link href="/2020/04/16/iOS%E4%B9%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88%EF%BC%88%E9%94%81%EF%BC%89/"/>
    <url>/2020/04/16/iOS%E4%B9%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88%EF%BC%88%E9%94%81%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>近期要写一个多线程工具，把之前学习的多线程，以及线程同步复习一下 </p><p>多线程的本质：有多条线程，但是只能执行一条，如果间隔时间设置的足够小，就给人的感觉是多条线程是同时进行的，时间片轮转调度算法</p><p>iOS中线程同步方案</p><ul><li>OSSpinLock</li><li>os_unfair_lock</li><li>pthread_mutex</li><li>dispatch_semaphore</li><li>Dispatch_queue(DISPATCH_QUEUE_SERIAL)</li><li>NSLock</li><li>NSRecursiveLock</li><li>NSCondition</li><li>NSConditionLock</li><li>@synchronized</li></ul><h4 id="OSSpinLock-自旋锁"><a href="#OSSpinLock-自旋锁" class="headerlink" title="OSSpinLock - 自旋锁"></a>OSSpinLock - 自旋锁</h4><p> 等待锁🔐的线程会处于忙等状态，一直占用CPU资源</p><p>会出现优先级翻转的问题，如果线程之间的优先级不同，如果低优先级的锁先进来，把锁锁住，那么高优先级的线程进来就会一直忙等，但是系统又会分配时间资源给线程高的，从而导致低优先级的线程无法执行完自己的代码，从而导致优先级低的锁无法释放。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">/// 初始化锁<br>self.lock = OS_SPINLOCK_INIT;<br>   <br>- (void)saleTicket&#123;<br>    /// 加锁<br>  OSSpinLockLock(&amp;_lock);<br>  //BOOL isLock =  OSSpinLockTry(&amp;_lock); <br>  int oldTicketsCount = self.ticketsCount;<br>  sleep(.2);<br>  oldTicketsCount--;<br>  self.ticketsCount = oldTicketsCount;<br>  NSLog(@&quot;还剩下%d张票 = %@&quot;,self.ticketsCount,[NSThread currentThread]);<br>  /// 解锁<br>  OSSpinLockUnlock(&amp;_lock);<br>&#125;<br>   <br></code></pre></td></tr></table></figure><hr><h4 id="os-unfair-lock-iOS10后支持-（本质是互斥锁）"><a href="#os-unfair-lock-iOS10后支持-（本质是互斥锁）" class="headerlink" title="os_unfair_lock - iOS10后支持 （本质是互斥锁）"></a>os_unfair_lock - iOS10后支持 （本质是互斥锁）</h4><p>用于替代<code>OSSpinLock</code> 的锁，使用的技术不再是忙等，而是休眠等待唤醒</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">/// 初始化锁<br>self.lock = OS_UNFAIR_LOCK_INIT;<br>- (void)saleTicket&#123;   <br>    /// 加锁<br>    os_unfair_lock_lock(&amp;_lock);<br>//  BOOL isLock = os_unfair_lock_trylock(&amp;lock);<br>    // 卖票<br>    [self sale];<br>    /// 解锁<br>    os_unfair_lock_unlock(&amp;_lock);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread_mutex"></a>pthread_mutex</h4><p><code>mutex</code> 叫做”互斥锁”，等待锁的线程会处于休眠状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">/// 初始化属性    <br>pthread_mutexattr_t attr;<br>pthread_mutexattr_init(&amp;attr);<br>pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_DEFAULT);<br>/// 初始化锁<br>pthread_mutex_init(&amp;_lock, &amp;attr);<br><br>//销毁属性 pthread_mutexattr_destroy(&amp;attr);<br>//销毁锁   pthread_mutex_destroy(&amp;_lock);<br><br>- (void)saleTicket&#123; <br>    /// 加锁<br>    pthread_mutex_lock(&amp;_lock);<br>    ///尝试 加锁<br>    //BOOL islock = pthread_mutex_trylock(&amp;_lock);<br>    // 卖票<br>    [self sale];<br>    /// 解锁<br>    pthread_mutex_unlock(&amp;_lock);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">/*<br> * Mutex type attributes<br> */<br>#define PTHREAD_MUTEX_NORMAL0  //普通状态锁<br>#define PTHREAD_MUTEX_ERRORCHECK1<br>#define PTHREAD_MUTEX_RECURSIVE2  //用于处理递归锁<br>#define PTHREAD_MUTEX_DEFAULTPTHREAD_MUTEX_NORMAL<br><br></code></pre></td></tr></table></figure><h5 id="递归锁"><a href="#递归锁" class="headerlink" title="递归锁"></a>递归锁</h5><p>递归锁：允许同一个线程对一把锁重复加锁</p><p>线程一 : 调用<code>saleTicket</code> (+🔐)</p><ul><li>调用<code>saleTicket</code> (+🔐)</li><li>调用<code>saleTicket</code> (+🔐)</li></ul><p> 线程二：调用<code>saleTicket</code> (发现已经被加锁了，等待) </p><p>当锁中间的代码遇到递归调用，打印的结果永远只有一条<code>saleTicket</code>，因为没有人能够走到解锁的那一步。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss">- (void)saleTicket&#123;<br>    <span class="hljs-comment">/// 加锁</span><br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;_lock);<br>    <span class="hljs-comment">///尝试 加锁</span><br>    <span class="hljs-comment">//BOOL islock = pthread_mutex_trylock(&amp;_lock);</span><br>    <span class="hljs-built_in">NSLog</span>(@&quot;%s&quot;,__func__);<br>    <span class="hljs-comment">// 卖票 递归调用</span><br>    <span class="hljs-selector-attr">[self saleTicket]</span>;<br>    <span class="hljs-comment">/// 解锁</span><br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;_lock);<br> <br>&#125;<br></code></pre></td></tr></table></figure><p> <code>pthread</code>是支持递归锁的，只需要把初始化属性改为递归锁</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);<br></code></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxupqijd8nj30c205igme.jpg"></p><h5 id="条件锁"><a href="#条件锁" class="headerlink" title="条件锁"></a>条件锁</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@property (nonatomic, assign) pthread_cond_t cond;<br><br>/// 初始化条件<br>pthread_mutex_init(&amp;_lock, &amp;attr);<br><br>// 销毁条件<br>pthread_cond_destroy(&amp;_cond);<br><br>[[[NSThread alloc]initWithTarget:self selector:@selector(__remove) object:nil]start];<br>[[[NSThread alloc]initWithTarget:self selector:@selector(__add) object:nil]start];<br><br>- (void)__remove&#123;<br>   <br>    pthread_mutex_lock(&amp;_lock);<br>    <br>    if (self.dataArray.count == 0) &#123;<br>        //一旦进入等待状态，就会放开这把锁，直到别人发送信号唤醒<br>        pthread_cond_wait(&amp;_cond, &amp;_lock);<br>    &#125;<br>    [self.dataArray removeLastObject];<br>    NSLog(@&quot;删除了元素&quot;);<br>    pthread_mutex_unlock(&amp;_lock);<br>&#125;<br><br>- (void)__add&#123;<br>    <br>    pthread_mutex_lock(&amp;_lock);<br>    <br>    [self.dataArray addObject:@&quot;123&quot;];<br>    NSLog(@&quot;添加了元素&quot;);<br>     <br>    pthread_cond_signal(&amp;_cond);<br>    pthread_mutex_unlock(&amp;_lock);<br>    // 这里需要保证pthread_cond_signal在pthread_mutex_unlock之前<br>    // 如果在之后的话，锁解开了，发送信号的这个过程中有可能被别的锁抢先进来了<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h4 id="NSLock-x2F-NSRecursiveLock-x2F-NSCondition"><a href="#NSLock-x2F-NSRecursiveLock-x2F-NSCondition" class="headerlink" title="NSLock&#x2F;NSRecursiveLock&#x2F;NSCondition"></a>NSLock&#x2F;NSRecursiveLock&#x2F;NSCondition</h4><ul><li><p><code>NSLock</code>是对<code>mutex</code>普通锁的封装</p></li><li><p><code>NSRecursiveLock</code> 是对<code>mutex</code>递归锁的封装</p></li><li><p><code>NSCondition</code> 是对<code>mutex</code>和<code>cont</code>的封装</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@protocol NSLocking<br><br>- (void)lock;<br>- (void)unlock;<br><br>@end<br><br>@interface NSLock : NSObject &lt;NSLocking&gt; &#123;<br>@private<br>    void *_priv;<br>&#125;<br><br>- (BOOL)tryLock; // 尝试加锁<br>- (BOOL)lockBeforeDate:(NSDate *)limit; //在这个时间之前等不到这个锁，都会睡眠<br><br>@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));<br>@end<br></code></pre></td></tr></table></figure><p>可以查看GNUStep看到<code>NSLock</code>的实现</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxusubtzxlj30js0b8400.jpg"></p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@interface NSConditionLock : NSObject &lt;NSLocking&gt; &#123;<br>@private<br>    void *_priv;<br>&#125;<br><br>- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;<br><br>@property (readonly) NSInteger condition;<br>- (void)lockWhenCondition:(NSInteger)condition;<br>- (BOOL)tryLock;<br>- (BOOL)tryLockWhenCondition:(NSInteger)condition;<br>- (void)unlockWithCondition:(NSInteger)condition;<br>- (BOOL)lockBeforeDate:(NSDate *)limit;<br>- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;<br><br>@property (nullable, copy) NSString *name API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));<br><br>@end<br></code></pre></td></tr></table></figure><hr><h4 id="Dispatch-queue-DISPATCH-QUEUE-SERIAL-串行队列"><a href="#Dispatch-queue-DISPATCH-QUEUE-SERIAL-串行队列" class="headerlink" title="Dispatch_queue(DISPATCH_QUEUE_SERIAL) - 串行队列"></a>Dispatch_queue(DISPATCH_QUEUE_SERIAL) - 串行队列</h4><ul><li>串行队列，也可以实现线程同步，保证了每一条线程的操作都是按顺序的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">  @property (nonatomic, strong) dispatch_queue_t  queen;<br>  <br>  self.queen =  dispatch_queue_create(&quot;123&quot;, DISPATCH_QUEUE_SERIAL);<br>  <br>  - (void)test&#123;<br>    self.ticketsCount = 20;<br>    <br>    dispatch_async(self.queen, ^&#123;<br>        for (int i = 0; i&lt;5; i++) &#123;<br>            [self saleTicket];<br>        &#125;<br>    &#125;);<br>    <br>    dispatch_async(self.queen, ^&#123;<br>        for (int i = 0; i&lt;5; i++) &#123;<br>            [self saleTicket];<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="dispatch-semaphore-信号量"><a href="#dispatch-semaphore-信号量" class="headerlink" title="dispatch_semaphore - 信号量"></a>dispatch_semaphore - 信号量</h4><ul><li>信号量的初始值，可以用来控制线程的并发访问的最大数量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@property (nonatomic, strong) dispatch_semaphore_t semaphore;<br>  // 设置最大并发数     <br> self.semaphore = dispatch_semaphore_create(1);<br>      <br>  for (int i = 0; i&lt;20; i++) &#123;<br>     [[[NSThread alloc]initWithTarget:self selector:@selector(test) object:nil]start];<br>  &#125;<br>  <br>- (void)test&#123;    <br>    // 如果信号量的值&gt;0,就让信号量减1，然后继续执行下面的代码<br>    // 直到信号量的值&lt;=0的时候，就会休眠等待<br>    // DISPATCH_TIME_FOREVER永远 或者 设置成 DISPATCH_TIME_NOW现在立即<br>    dispatch_semaphore_wait(self.semaphore, DISPATCH_TIME_FOREVER);<br>    self.ticketsCount--;<br>    sleep(2);<br>    NSLog(@&quot;剩下的票为 %d&quot;,self.ticketsCount);<br>    //让信号量的值+1<br>    dispatch_semaphore_signal(self.semaphore);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="@synchronized"></a>@synchronized</h4><ul><li><code>@synchronized</code>是对<code>mutex</code>递归锁的封装</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">@synchronized (self) &#123; //objc_sync_enter<br>&#125; // objc_sync_exit<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs objective-c">int objc_sync_enter(id obj)<br>&#123;<br>    int result = OBJC_SYNC_SUCCESS;<br><br>    if (obj) &#123;<br>        SyncData* data = id2data(obj, ACQUIRE);<br>        ASSERT(data);<br>        data-&gt;mutex.lock();<br>    &#125; else &#123;<br>        // @synchronized(nil) does nothing<br>        if (DebugNilSync) &#123;<br>            _objc_inform(&quot;NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug&quot;);<br>        &#125;<br>        objc_sync_nil();<br>    &#125;<br><br>    return result;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>id2data</code> 方法内部</p><p>![image-20211229175537934](&#x2F;Users&#x2F;karthrine&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20211229175537934.png)</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxuusl6m2wj30cm01z74g.jpg"></p><p>内部是一个哈希表，把<code>obj</code>当做<code>key</code> ，<code>data-&gt;mutex.lock();</code> 拿到唯一的mutex锁，来加锁</p><hr><h4 id="自旋锁和互斥锁对比"><a href="#自旋锁和互斥锁对比" class="headerlink" title="自旋锁和互斥锁对比"></a>自旋锁和互斥锁对比</h4><p>什么情况下使用自旋锁比较划算？</p><ul><li>预计线程等待锁的时间很短</li><li>加锁的代码（临界区）经常被调用，但竞争情况很少发送</li><li>CPU资源不紧张</li><li>多核处理器</li></ul><p>什么情况下使用互斥锁比较划算？</p><ul><li>预计线程等待锁的时间较长</li><li>单核处理器</li><li>临界区有IO操作</li><li>临界区代码复杂或者循环量大</li></ul>]]></content>
    
    
    <categories>
      
      <category>iOS</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
